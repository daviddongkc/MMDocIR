{"page": 0, "image_path": "doc_images/D18-1287_0.jpg", "ocr_text": "Mapping Instructions to Actions in 3D Environments\nwith Visual Goal Prediction\n\nAndrew Bennett\n\nShatkhin\n\nValts Blukis\nYoav Artzi\n\nDepartment of Computer Science and Cornell Tech, Cornell University, New York, NY, 10044\nyoav}@cs.cornell.edu\n\nDipendra Misra\nEyvind Niklasson Max\n{dkm, awbennett, valts,\n{een7,\nAbstract\n\nWe propose to decompose instruction exe-\ncution to goal prediction and action genera-\ntion. We design a model that maps raw vi-\nsual observations to goals using LINGUNET,\na language-conditioned image generation net-\nwork, and then generates the actions required\nto complete them. Our model is trained\nfrom demonstration only without external re-\nsources. To evaluate our approach, we intro-\nduce two benchmarks for instruction follow-\n\nms3448}@cornell.edu\n\nAfter reaching the hydrant\nhead towards the blue\nfence and pass towards the\nright side of the well.\n\nPut the cereal, the sponge,\nand the dishwashing soap\ninto the cupboard above\nthe sink.\n\ning: LANI, a navigation task; and CHAI, where\nan agent executes household instructions. Our\nevaluation demonstrates the advantages of our\nmodel decomposition, and illustrates the chal-\nlenges posed by our new benchmarks.\n\n1 Introduction\n\nExecuting instructions in interactive environments\nrequires mapping natural language and observa-\ntions to actions. Recent approaches propose learn-\ning to directly map from inputs to actions, for ex-\nample given language and either structured obser-\nvations (Mei et al., 2016; Suhr and Artzi, 2018) or\nraw visual observations (Misra et al., 2017; Xiong\net al., 2018). Rather than using a combination\nof models, these approaches learn a single model\nto solve language, perception, and planning chal-\nlenges. This reduces the amount of engineering\nrequired and eliminates the need for hand-crafted\nmeaning representations. At each step, the agent\nmaps its current inputs to the next action using a\nsingle learned function that is executed repeatedly\nuntil task completion.\n\nAlthough executing the same computation at\neach step simplifies modeling, it exemplifies cer-\ntain inefficiencies; while the agent needs to de-\ncide what action to take at each step, identifying\nits goal is only required once every several steps\nor even once per execution. The left instruction in\nFigure | illustrates this. The agent can compute its\n\nFigure 1: Example instructions from our two tasks:\nLANI (left) and CHAI (right). LANI is a landmark nav-\nigation task, and CHAI is a corpus of instructions in the\nCHALET environment.\n\ngoal once given the initial observation, and given\nthis goal can then generate the actions required.\nIn this paper, we study a new model that explic-\nitly distinguishes between goal selection and ac-\ntion generation, and introduce two instruction fol-\nlowing benchmark tasks to evaluate it.\n\nOur model decomposes into goal prediction and\naction generation. Given a natural language in-\nstruction and system observations, the model pre-\ndicts the goal to complete. Given the goal, the\nmodel generates a sequence of actions.\n\nThe key challenge we address is designing the\ngoal representation. We avoid manually designing\na meaning representation, and predict the goal in\nthe agent’s observation space. Given the image of\nthe environment the agent observes, we generate a\nprobability distribution over the image to highlight\nthe goal location. We treat this prediction as image\ngeneration, and develop LINGUNET, a language\nconditioned variant of the U-NET image-to-image\narchitecture (Ronneberger et al., 2015). Given the\nvisual goal prediction, we generate actions using a\nrecurrent neural network (RNN).\n\nOur model decomposition offers two key advan-\ntages. First, we can use different learning methods\nas appropriate for the goal prediction and action\n\n2667\n\nProceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 2667-2678\nBrussels, Belgium, October 31 - November 4, 2018. ©2018 Association for Computational Linguistics\n", "vlm_text": "Mapping Instructions to Actions in 3D Environments with Visual Goal Prediction \nDipendra Misra Andrew Bennett Valts Blukis Eyvind Niklasson Max Shatkhin Yoav Artzi \nDepartment of Computer Science and Cornell Tech, Cornell University, New York, NY, 10044 {dkm, awbennett, valts, yoav}@cs.cornell.edu {een7, ms3448}@cornell.edu \nAbstract \nWe propose to decompose instruction exe- cution to goal prediction and action genera- tion. We design a model that maps raw vi- sual observations to goals using L ING UN ET , a language-conditioned image generation net- work, and then generates the actions required to complete them. Our model is trained from demonstration only without external re- sources. To evaluate our approach, we intro- duce two benchmarks for instruction follow- ing: L ANI , a navigation task; and C HAI , where an agent executes household instructions. Our evaluation demonstrates the advantages of our model decomposition, and illustrates the chal- lenges posed by our new benchmarks. \n1 Introduction \nExecuting instructions in interactive environments requires mapping natural language and observa- tions to actions. Recent approaches propose learn- ing to directly map from inputs to actions, for ex- ample given language and either structured obser- vations ( Mei et al. ,  2016 ;  Suhr and Artzi ,  2018 ) or raw visual observations ( Misra et al. ,  2017 ;  Xiong et al. ,  2018 ). Rather than using a combination of models, these approaches learn a single model to solve language, perception, and planning chal- lenges. This reduces the amount of engineering required and eliminates the need for hand-crafted meaning representations. At each step, the agent maps its current inputs to the next action using a single learned function that is executed repeatedly until task completion. \nAlthough executing the same computation at each step simpliﬁes modeling, it exempliﬁes cer- tain inefﬁciencies; while the agent needs to de- cide what action to take at each step, identifying its goal is only required once every several steps or even once per execution. The left instruction in Figure  1  illustrates this. The agent can compute its \nThe image consists of two separate panels, each depicting a different scene accompanied by captions below each.\n\nThe left panel shows an outdoor scene that includes a green lawn with a well in the foreground. Behind the well, there is a blue fence and a couple of cactus plants. It seems to be either afternoon or night since the sky is dark. The caption underneath reads: \"After reaching the hydrant head towards the blue fence and pass towards the right side of the well.\"\n\nThe right panel displays a part of a kitchen. There is a countertop with a sink, a sponge, a bottle of dishwashing soap, and a container or package that resembles a box of cereal. Above the counter are cabinets. The caption below this panel states: \"Put the cereal, the sponge, and the dishwashing soap into the cupboard above the sink.\"\nFigure 1: Example instructions from our two tasks: L ANI  (left) and C HAI  (right). L ANI  is a landmark nav- igation task, and C HAI  is a corpus of instructions in the C HALET  environment. \ngoal once given the initial observation, and given this goal can then generate the actions required. In this paper, we study a new model that explic- itly distinguishes between goal selection and ac- tion generation, and introduce two instruction fol- lowing benchmark tasks to evaluate it. \nOur model decomposes into goal prediction and action generation. Given a natural language in- struction and system observations, the model pre- dicts the goal to complete. Given the goal, the model generates a sequence of actions. \nThe key challenge we address is designing the goal representation. We avoid manually designing a meaning representation, and predict the goal in the agent’s observation space. Given the image of the environment the agent observes, we generate a probability distribution over the image to highlight the goal location. We treat this prediction as image generation, and develop L ING UN ET , a language conditioned variant of the U-N ET  image-to-image architecture ( Ronneberger et al. ,  2015 ). Given the visual goal prediction, we generate actions using a recurrent neural network (RNN). \nOur model decomposition offers two key advan- tages. First, we can use different learning methods as appropriate for the goal prediction and action generation problems. We ﬁnd supervised learning more effective for goal prediction, where only a limited amount of natural language data is avail- able. For action generation, where exploration is critical, we use policy gradient in a contextual ban- dit setting ( Misra et al. ,  2017 ). Second, the goal distribution is easily interpretable by overlaying it on the agent observations. This can be used to in- crease the safety of physical systems by letting the user verify the goal before any action is executed. Despite the decomposition, our approach retains the advantages of the single-model approach. It does not require designing intermediate represen- tations, and training does not rely on external re- sources, such as pre-trained parsers or object de- tectors, instead using demonstrations only. "}
{"page": 1, "image_path": "doc_images/D18-1287_1.jpg", "ocr_text": "generation problems. We find supervised learning\nmore effective for goal prediction, where only a\nlimited amount of natural language data is avail-\nable. For action generation, where exploration is\ncritical, we use policy gradient in a contextual ban-\ndit setting (Misra et al., 2017). Second, the goal\ndistribution is easily interpretable by overlaying it\non the agent observations. This can be used to in-\ncrease the safety of physical systems by letting the\nuser verify the goal before any action is executed.\nDespite the decomposition, our approach retains\nthe advantages of the single-model approach. It\ndoes not require designing intermediate represen-\ntations, and training does not rely on external re-\nsources, such as pre-trained parsers or object de-\ntectors, instead using demonstrations only.\n\nWe introduce two new benchmark tasks with\ndifferent levels of complexity of goal prediction\nand action generation. LANI is a 3D navigation\nenvironment and corpus, where an agent navigates\nbetween landmarks. The corpus includes 6,000\nsequences of natural language instructions, each\ncontaining on average 4.7 instructions. CHAI is\na corpus of 1,596 instruction sequences, each in-\ncluding 7.7 instructions on average, for CHALET,\na 3D house environment (Yan et al., 2018). In-\nstructions combine navigation and simple manipu-\nlation, including moving objects and opening con-\ntainers. Both tasks require solving language chal-\nlenges, including spatial and temporal reasoning,\nas well as complex perception and planning prob-\nlems. While LANI provides a task where most in-\nstructions include a single goal, the CHAI instruc-\ntions often require multiple intermediate goals.\nFor example, the household instruction in Fig-\nure 1 can be decomposed to eight goals: opening\nthe cupboard, picking each item and moving it to\nthe cupboard, and closing the cupboard. Achiev-\ning each goal requires multiple actions of differ-\nent types, including moving and acting on objects.\nThis allows us to experiment with a simple varia-\ntion of our model to generate intermediate goals.\n\nWe compare our approach to multiple recent\nmethods. Experiments on the LANI navigation\ntask indicate that decomposing goal prediction\nand action generation significantly improves in-\nstruction execution performance. While we ob-\nserve similar trends on the CHAI instructions, re-\nsults are overall weaker, illustrating the complex-\nity of the task. We also observe that inherent\nambiguities in instruction following make exact\n\ngoal identification difficult, as demonstrated by\nimperfect human performance. However, the gap\nto human-level performance still remains large\nacross both tasks. Our code and data are available\nat github.com/clic-lab/ciff.\n\n2 Technical Overview\n\nTask Let % be the set of all instructions, S the\nset of all world states, and A the set of all actions.\nAn instruction  € ¥ is a sequence (x,...,2n),\nwhere each x; is a token. The agent executes\ninstructions by generating a sequence of actions,\nand indicates execution completion with the spe-\ncial action STOP.\n\nThe sets of actions A and states S are domain\nspecific. In the navigation domain LANTI, the ac-\ntions include moving the agent and changing its\norientation. The state information includes the po-\nsition and orientation of the agent and the differ-\nent landmarks. The agent actions in the CHALET\nhouse environment include moving and changing\nthe agent orientation, as well as an object interac-\ntion action. The state encodes the position and ori-\nentation of the agent and all objects in the house.\nFor interactive objects, the state also includes their\nstatus, for example if a drawer is open or closed.\nIn both domains, the actions are discrete. The do-\nmains are described in Section 6.\n\nModel The agent does not observe the world\nstate directly, but instead observes its pose and an\nRGB image of the environment from its point of\nview. We define these observations as the agent\ncontext §. An agent model is a function from an\nagent context § to an action a € A. We model\ngoal prediction as predicting a probability distri-\nbution over the agent visual observations, repre-\nsenting the likelihood of locations or objects in the\nenvironment being target positions or objects to be\nacted on. Our model is described in Section 4.\n\nLearning We assume access to training data\nwith N examples {(2©, 3, IN, where 7)\nis an instruction, 3) is a start state, and 3? is the\ngoal state. We decompose learning; training goal\nprediction using supervised learning, and action\ngeneration using oracle goals with policy gradient\nin a contextual bandit setting. We assume an in-\nstrumented environment with access to the world\nstate, which is used to compute rewards during\ntraining only. Learning is described in Section 5.\n\nEvaluation We evaluate task performance on a\n\ntest set {(£, 3, 3f))}M, where Z is an in-\n\n2668\n", "vlm_text": "\nWe introduce two new benchmark tasks with different levels of complexity of goal prediction and action generation. L ANI  is a 3D navigation environment and corpus, where an agent navigates between landmarks. The corpus includes 6,000 sequences of natural language instructions, each containing on average 4.7 instructions. C HAI  is a corpus of 1,596 instruction sequences, each in- cluding 7.7 instructions on average, for C HALET , a 3D house environment ( Yan et al. ,  2018 ). In- structions combine navigation and simple manipu- lation, including moving objects and opening con- tainers. Both tasks require solving language chal- lenges, including spatial and temporal reasoning, as well as complex perception and planning prob- lems. While L ANI  provides a task where most in- structions include a single goal, the C HAI  instruc- tions often require multiple intermediate goals. For example, the household instruction in Fig- ure  1  can be decomposed to eight goals: opening the cupboard, picking each item and moving it to the cupboard, and closing the cupboard. Achiev- ing each goal requires multiple actions of differ- ent types, including moving and acting on objects. This allows us to experiment with a simple varia- tion of our model to generate intermediate goals. \nWe compare our approach to multiple recent methods. Experiments on the L ANI  navigation task indicate that decomposing goal prediction and action generation signiﬁcantly improves in- struction execution performance. While we ob- serve similar trends on the C HAI  instructions, re- sults are overall weaker, illustrating the complex- ity of the task. We also observe that inherent ambiguities in instruction following make exact goal identiﬁcation difﬁcult, as demonstrated by imperfect human performance. However, the gap to human-level performance still remains large across both tasks. Our code and data are available at  github.com/clic-lab/ciff . \n\n2 Technical Overview \nTask Let    $\\mathcal{X}$   be the set o ll  instructions ,    $s$   the set of all  world  and  A  the set of all  actions . An instruction  $\\bar{x}\\in\\mathcal X$   2 X  is a sequence    $\\langle x_{1},\\ldots,x_{n}\\rangle$  , where each    $x_{i}$   is a token. The agent executes instructions by generating a sequence of actions, and indicates execution completion with the spe- cial action  STOP . \nThe sets of actions    $\\mathcal{A}$   and states    $s$   are domain speciﬁc. In the navigation domain L ANI , the ac- tions include moving the agent and changing its orientation. The state information includes the po- sition and orientation of the agent and the differ- ent landmarks. The agent actions in the C HALET house environment include moving and changing the agent orientation, as well as an object interac- tion action. The state encodes the position and ori- entation of the agent and all objects in the house. For interactive objects, the state also includes their status, for example if a drawer is open or closed. In both domains, the actions are discrete. The do- mains are described in Section  6 . \nModel The agent does not observe the world state directly, but instead observes its pose and an RGB image of the environment from its point of view. We deﬁne these observations as the agent context  ˜ . An agent model is a function from an agent context  $\\tilde{s}$   to an action    $a\\,\\in\\,{\\mathcal{A}}$  . We model goal prediction as predicting a probability distri- bution over the agent visual observations, repre- senting the likelihood of locations or objects in the environment being target positions or objects to be acted on. Our model is described in Section  4 . \nLearning We assume access to training data with    $N$   examples  {  $\\{(\\bar{x}^{(i)},s_{1}^{(i)},s_{g}^{(i)})\\}_{i=1}^{N}$  , where  $\\bar{x}^{(i)}$  is an instruction,  $s_{1}^{(i)}$    is a start state, and    $s_{g}^{(i)}$  is the goal state. We decompose learning; training goal prediction using supervised learning, and action generation using oracle goals with policy gradient in a contextual bandit setting. We assume an in- strumented environment with access to the world state, which is used to compute rewards during training only. Learning is described in Section  5 . \nEvaluation We evaluate task performance on a test set  {  $\\{(\\bar{x}^{(i)},s_{1}^{(i)},s_{g}^{(i)})\\}_{i=1}^{M}$  , where    $\\bar{x}^{(i)}$    is an in- struction,    $s_{1}^{(i)}$  is a start state, and    $s_{g}^{(i)}$  is the goal state. We evaluate task completion accuracy and the distance of the agent’s ﬁnal state to    $s_{g}^{(i)}$  . "}
{"page": 2, "image_path": "doc_images/D18-1287_2.jpg", "ocr_text": "struction, 3? is a start state, and sf) is the goal\n\nstate. We evaluate task completion accuracy and\n\nthe distance of the agent’s final state to sf),\n\n3 Related Work\n\nMapping instruction to action has been studied\nextensively with intermediate symbolic represen-\ntations (e.g., Chen and Mooney, 2011; Kim and\nMooney, 2012; Artzi and Zettlemoyer, 2013; Artzi\net al., 2014; Misra et al., 2015, 2016). Recently,\nthere has been growing interest in direct mapping\nfrom raw visual observations to actions (Misra\net al., 2017; Xiong et al., 2018; Anderson et al.,\n2018; Fried et al., 2018). We propose a model that\nenjoys the benefits of such direct mapping, but ex-\nplicitly decomposes that task to interpretable goal\nprediction and action generation. While we focus\non natural language, the problem has also been\nstudied using synthetic language (Chaplot et al.,\n2018; Hermann et al., 2017).\n\nOur model design is related to hierarchical re-\ninforcement learning, where sub-policies at differ-\nent levels of the hierarchy are used at different fre-\nquencies (Sutton et al., 1998). Oh et al. (2017)\nuses a two-level hierarchy for mapping synthetic\nlanguage to actions. Unlike our visual goal rep-\nresentation, they use an opaque vector representa-\ntion. Also, instead of reinforcement learning, our\nmethods emphasize sample efficiency.\n\nGoal prediction is related to referring expres-\nsion interpretation (Matuszek et al., 2012a; Krish-\nnamurthy and Kollar, 2013; Kazemzadeh et al.,\n2014; Kong et al., 2014; Yu et al., 2016; Mao et al.,\n2016; Kitaev and Klein, 2017). While our model\nsolves a similar problem for goal prediction, we\nfocus on detecting visual goals for actions, includ-\ning both navigation and manipulation, as part of\nan instruction following model. Using formal goal\nrepresentation for instruction following was stud-\nied by MacGlashan et al. (2015). In contrast, our\nmodel generates a probability distribution over im-\nages, and does not require an ontology.\n\nOur data collection is related to existing work.\nLANI is inspired by the HCRC Map Task (An-\nderson et al., 1991), where a leader directs a fol-\nlower to navigate between landmarks on a map.\nWe use a similar task, but our scalable data collec-\ntion process allows for a significantly larger cor-\npus. We also provide an interactive navigation\nenvironment, instead of only map diagrams. Un-\nlike Map Task, our leaders and followers do not\ninteract in real time. This abstracts away inter-\n\naction challenges, similar to how the SAIL nav-\nigation corpus was collected (MacMahon et al.,\n2006). CHAI instructions were collected using\nscenarios given to workers, similar to the ATIS\ncollection process (Hemphill et al., 1990; Dahl\net al., 1994). Recently, multiple 3D research envi-\nronments were released. LANI has a significantly\nlarger state space than existing navigation envi-\nronments (Hermann et al., 2017; Chaplot et al.,\n2018), and CHALET, the environment used for\nCHAI, is larger and has more complex manipu-\nlation compared to similar environments (Gordon\net al., 2018; Das et al., 2018). In addition, only\nsynthetic language data has been released for these\nenvironment. An exception is the Room-to-Room\ndataset (Anderson et al., 2018) that makes use of\nan environment of connected panoramas of house\nsettings. Although it provides a realistic vision\nchallenge, unlike our environments, the state space\nis limited to a small number of panoramas and ma-\nnipulation is not possible.\n\n4 Model\n\nWe model the agent policy as a neural network.\nThe agent observes the world state s, at time t as\nan RGB image I;. The agent context 5;, the infor-\nmation available to the agent to select the next ac-\ntion a, is a tuple (Z, Ip, ((I1,pi),..., (Ie, pt))),\nwhere is the natural language instructions,\nIp is a panoramic view of the environment\nfrom the starting position at time t = 1, and\n(li, pi), ---; (Iz, pt) is the sequence of observa-\ntions I, and poses p; up to time t. The panorama\nIp is generated through deterministic exploration\nby rotating 360° to observe the environment at the\nbeginning of the execution.!\n\nThe model includes two main components: goal\nprediction and action generation. The agent uses\nthe panorama Ip to predict the goal location ly. At\neach time step t, a projection of the goal location\ninto the agent’s current view M, is given as input\nto an RNN to generate actions. The probability of\nan action a; at time t decomposes to:\n\nPar | 5) = Yo (PUy | #,1r)\n\nL\n\n9\n\nPCa | Ug, (Las Pr)s---s(TesPe)))\nwhere the first term puts the complete distribution\nmass on a single location (i.e., a delta function).\nFigure 2 illustrates the model.\n\n'The panorama is a concatenation of deterministic obser-\n\nvations along the width dimension. For simplicity, we do not\ninclude these deterministic steps in the execution.\n\n2669\n", "vlm_text": "\n3 Related Work \nMapping instruction to action has been studied extensively with intermediate symbolic represen- tations (e.g.,  Chen and Mooney ,  2011 ;  Kim and Mooney ,  2012 ;  Artzi and Zettlemoyer ,  2013 ;  Artzi et al. ,  2014 ;  Misra et al. ,  2015 ,  2016 ). Recently, there has been growing interest in direct mapping from raw visual observations to actions ( Misra et al. ,  2017 ;  Xiong et al. ,  2018 ;  Anderson et al. , 2018 ;  Fried et al. ,  2018 ). We propose a model that enjoys the beneﬁts of such direct mapping, but ex- plicitly decomposes that task to interpretable goal prediction and action generation. While we focus on natural language, the problem has also been studied using synthetic language ( Chaplot et al. , 2018 ;  Hermann et al. ,  2017 ). \nOur model design is related to hierarchical re- inforcement learning, where sub-policies at differ- ent levels of the hierarchy are used at different fre- quencies ( Sutton et al. ,  1998 ).  Oh et al.  ( 2017 ) uses a two-level hierarchy for mapping synthetic language to actions. Unlike our visual goal rep- resentation, they use an opaque vector representa- tion. Also, instead of reinforcement learning, our methods emphasize sample efﬁciency. \nGoal prediction is related to referring expres- sion interpretation ( Matuszek et al. ,  2012a ;  Krish- namurthy and Kollar ,  2013 ;  Kazemzadeh et al. , 2014 ;  Kong et al. ,  2014 ;  Yu et al. ,  2016 ;  Mao et al. , 2016 ;  Kitaev and Klein ,  2017 ). While our model solves a similar problem for goal prediction, we focus on detecting visual goals for actions, includ- ing both navigation and manipulation, as part of an instruction following model. Using formal goal representation for instruction following was stud- ied by  MacGlashan et al.  ( 2015 ). In contrast, our model generates a probability distribution over im- ages, and does not require an ontology. \nOur data collection is related to existing work. L ANI  is inspired by the HCRC Map Task ( An- derson et al. ,  1991 ), where a leader directs a fol- lower to navigate between landmarks on a map. We use a similar task, but our scalable data collec- tion process allows for a signiﬁcantly larger cor- pus. We also provide an interactive navigation environment, instead of only map diagrams. Un- like Map Task, our leaders and followers do not interact in real time. This abstracts away inter- action challenges, similar to how the SAIL nav- igation corpus was collected ( MacMahon et al. , 2006 ). C HAI  instructions were collected using scenarios given to workers, similar to the ATIS collection process ( Hemphill et al. ,  1990 ;  Dahl et al. ,  1994 ). Recently, multiple 3D research envi- ronments were released. L ANI  has a signiﬁcantly larger state space than existing navigation envi- ronments ( Hermann et al. ,  2017 ;  Chaplot et al. , 2018 ), and C HALET , the environment used for C HAI , is larger and has more complex manipu- lation compared to similar environments ( Gordon et al. ,  2018 ;  Das et al. ,  2018 ). In addition, only synthetic language data has been released for these environment. An exception is the Room-to-Room dataset ( Anderson et al. ,  2018 ) that makes use of an environment of connected panoramas of house settings. Although it provides a realistic vision challenge, unlike our environments, the state space is limited to a small number of panoramas and ma- nipulation is not possible. \n\n4 Model \nWe model the agent policy as a neural network. The agent observes the world state    $s_{t}$   at time    $t$   as an RGB image    $\\mathbf{I}_{t}$  . The agent context  $\\tilde{s}_{t}$  , the infor- mation available to the agent to select the next ac- tion    $a_{t}$  , is a tuple    $({\\bar{x}},\\mathbf{I}_{P},\\langle(\\mathbf{I}_{1},p_{1}),.\\,.\\,,(\\mathbf{I}_{t},p_{t})\\rangle)$   h i , where    $\\bar{x}$   is the natural language instructions,  ${\\bf I}_{P}$  is a panoramic view of the environment from the starting position at time    $t~=~1$  , and  $\\langle(\\mathbf{I}_{1},p_{1}),.\\,.\\,,(\\mathbf{I}_{t},p_{t})\\rangle$   is the seq ence of observa- tions  $\\mathbf{I}_{t}$   and poses  $p_{t}$   up to time  t . The panorama  ${\\bf I}_{P}$   is generated through deterministic exploration by rotating  $360^{\\circ}$  to observe the environment at the beginning of the execution. \nThe model includes two main components: goal prediction and action generation. The agent uses the panorama  ${\\bf I}_{P}$   to predict the goal location  $l_{g}$  . At each time step  $t$  , a projection of the goal location into the agent’s current view    $\\mathbf{M}_{t}$   is given as input to an RNN to generate actions. The probability of an action    $a_{t}$   at time  $t$   decomposes to: \n\n$$\n\\begin{array}{l}{{P(a_{t}\\mid\\tilde{s}_{t})=\\displaystyle\\sum_{l_{g}}\\left(P(l_{g}\\mid\\bar{x},{\\mathbf{I}_{P}})\\right.}}\\\\ {{\\displaystyle\\qquad\\qquad\\left.P(a_{t}\\mid l_{g},({\\mathbf{I}_{1}},p_{1}),.\\,.\\,,({\\mathbf{I}_{t}},p_{t}))\\right)~,}}\\end{array}\n$$\n \nwhere the ﬁrst term puts the complete distribution mass on a single location (i.e., a delta function). Figure  2  illustrates the model. "}
{"page": 3, "image_path": "doc_images/D18-1287_3.jpg", "ocr_text": "Instruction &\nTurn left and go to the red oil drum\ni—I—-I-E-# I GH-1 1\n\nPanorama Image I,\n\nGoal Distribution P,\n\n= Goal Location 1,\n\nLaan | Instruction Representation ¥\nFo PL pz -p3 Poses\nKm Ki Kf Kill Text Kernels nil Mt ot\nSoto 1 2 S\nF Gy Hy Goal Masks\nh_T] \" L\n¥\n\" : 3 i-i+-+-\n| G3 H. i\nFs +! | ¥ M ¥ :\nTURNLEFT TURNLEFT FORWARD Actions\nLingUNet\n\nFigure 2: An illustration\n\nor our architecture (Section 4) for the instruction turn left and go to the red oil drum\n\nwith a LINGUNET depth of m = 4. The instruction z is mapped to X with an RNN, and the initial panorama\nobservation Ip to Fo with a CNN. LINGUNET generates H}, a visual representation of the goal. First, a sequence\nof convolutions maps the image features Fo to feature maps Fy,...,F4. The text representation X is used to\ngenerate the kernels Ky,...,K4, which are convolved to generate the text-conditioned feature maps G,...,G4.\nThese feature maps are de-convolved to H,,...,H4. The goal probability distribution P, is computed from H,.\nThe goal location is the inferred from the max of P,. Given 1, and p,, the pose at step ¢, the goal mask M, is\ncomputed and passed into an RNN that outputs the action to execute.\n\nGoal Prediction To predict the goal location,\nwe generate a probability distribution P, over\na feature map Fo generated using convolutions\nfrom the initial panorama observation Ip. Each\nelement in the probability distribution P, corre-\nsponds to an area in Ip. Given the instruction\n& and panorama Ip, we first generate their rep-\nresentations. From the panorama Ip, we gener-\nate a feature map Fo = [CNNo(Ip); F?], where\nCNNpo is a two-layer convolutional neural net-\nwork (CNN; LeCun et al., 1998) with rectified\nlinear units (ReLU; Nair and Hinton, 2010) and\nF? are positional embeddings.” The concatena-\ntion is along the channel dimension. The instruc-\ntion Z = (x1,+++%p) is mapped to a sequence\nof hidden states 1; = LSTMz(¢2(xi), i-1), i =\n1,...,n using a learned embedding function q,,\nand a long short-term memory (LSTM; Hochre-\niter and Schmidhuber, 1997) RNN LSTM,;. The\ninstruction representation is X = 1,.\n\nWe generate the probability distribution P, over\npixels in Fo using LINGUNET. The architecture\nof LINGUNET is inspired by the U-NET image\ngeneration method (Ronneberger et al., 2015), ex-\ncept that the reconstruction phase is conditioned\non the natural language instruction. LINGUNET\nfirst applies m convolutional layers to generate a\nsequence of feature maps F; = CNN;(Fj_1),\n\nWe generate F? by creating a channel for each determin-\nistic observation used to create the panorama, and setting all\nthe pixels corresponding to that observation location in the\npanorama to 1 and all others to 0. The number of observa-\ntions depends on the agent’s camera angle.\n\nj =1...m, where each CNN; is a convolutional\nlayer with leaky ReLU non-linearities (Maas et al.,\n2013) and instance normalization (Ulyanov et al.,\n2016). The instruction representation X is split\nevenly into m vectors {Xj}, each is used to\ncreate a1 x 1 kernel K; = AFFINE;(X;), where\neach AFFINE; is an affine transformation followed\nby normalizing and reshaping. For each Fj, we\napply a 2D 1 x 1 convolution using the text ker-\nnel K; to generate a text-conditioned feature map\nG; = CONVOLVE(K;,F;), where CONVOLVE\nconvolves the kernel over the feature map. We\nthen perform m deconvolutions to generate a se-\nquence of feature maps H,»,...,H1:\n\nHn DECONV,, (DROPOUT(G,,))\n\nH, = DEconv,((Hj41:G,)) .\n\nDROPOUT is dropout regularization (Srivastava\net al., 2014) and each DECONV; is a decon-\nvolution operation followed a leaky ReLU non-\nlinearity and instance norm.’ Finally, we gener-\nate P, by applying a softmax to Hy and an ad-\nditional learned scalar bias term b, to represent\nevents where the goal is out of sight. For example,\nwhen the agent already stands in the goal position\nand therefore the panorama does not show it.\n\nWe use Py to predict the goal position in the\nenvironment. We first select the goal pixel in Fo as\nthe pixel corresponding to the highest probability\nelement in P,. We then identify the corresponding\n3D location J, in the environment using backward\ncamera projection, which is computed given the\n\n3DECONV, does deconvolution only.\n\n2670\n", "vlm_text": "The image is a diagram illustrating a neural network architecture used for processing navigation instructions. The caption and image detail the process of converting spoken or written instructions into navigational actions, specifically turning left and going to a red oil drum.\n\nHere's a breakdown of the diagram:\n\n1. **Instruction Processing:**\n   - The instruction \"Turn left and go to the red oil drum\" is represented as text, denoted by $\\bar{x}$.\n   - This text is processed by a Recurrent Neural Network (RNN) to map it to a representation $\\bar{\\bf x}$.\n\n2. **Initial Observation:**\n   - An initial panorama image ${\\bf I}_{P}$ is input into a Convolutional Neural Network (CNN) to generate an image feature map ${\\bf F}_{0}$.\n\n3. **LingUNet Generation:**\n   - LingUNet uses the text representation $\\bar{\\bf x}$ to generate text kernels $\\mathbf{K}_{1}, \\ldots, \\mathbf{K}_{4}^{-}$.\n   - A sequence of convolutions maps the initial image feature ${\\bf F}_{0}$ to layered feature maps: $\\mathbf{F}_{1}, \\dots, \\mathbf{F}_{4}$.\n   - These are combined with the text-conditioned kernels to produce text-conditioned feature maps $\\mathbf{G}_{1}, \\ldots, \\mathbf{G}_{4}$.\n\n4. **Deconvolution:**\n   - The text-conditioned feature maps are deconvolved to produce $\\mathbf{H}_{1}, \\ldots, \\mathbf{H}_{4}$.\n   - The first layer, $\\mathbf{H}_{1}$, is used to calculate a goal probability distribution, $P_{g}$.\n\n5. **Goal Location and Action Determination:**\n   - The goal probability distribution $P_{g}$ helps determine the goal location $l_{g}$ by identifying the peak probability.\n   - Given the current pose at step $t$, denoted as $p_{t}$, a goal mask $\\mathbf{M}_{t}$ is computed.\n   - This goal mask is input into an RNN to produce actions (e.g., TURNLEFT, FORWARD).\n\nOverall, the architecture integrates visual and textual inputs to guide navigation, where the system follows the instruction to turn left and reach the designated target based on its learned mappings and probability distributions.\nGoal Prediction To predict the goal location, we generate a probability distribution    $P_{g}$   over a feature map    ${\\bf F}_{0}$   generated using convolutions from the initial panorama observation    ${\\bf\\cal I}_{P}$  . Each element in the probability distribution    $P_{g}$   corre- sponds to an area in    ${\\bf I}_{P}$  . Given the instruction  $\\bar{x}$   and panorama    ${\\bf\\cal I}_{P}$  , we ﬁrst generate their rep- resentations. From the panorama    ${\\bf I}_{P}$  , we gener- ate a feature map    $\\mathbf{F}_{0}\\,=\\,[\\mathbf{CNN}_{0}(\\mathbf{I}_{P});\\mathbf{F}^{p}]$  , where  $\\mathbf{CNN}_{0}$   is a two-layer convolutional neural net- work (CNN;  LeCun et al. ,  1998 ) with rectiﬁed linear units (ReLU;  Nair and Hinton ,  2010 ) and  $\\mathbf{F}^{p}$    are positional embeddings.   The concatena- tion is along the channel dimension. The instruc- tion    $\\bar{\\boldsymbol{x}}~=~\\langle\\boldsymbol{x}_{1},\\cdot\\cdot\\cdot\\boldsymbol{x}_{n}\\rangle$   h  · · · i  is mapped to a sequence of hidden states    $\\mathbf{l}_{i}\\,=\\,\\mathrm{{LSTM}}_{x}(\\psi_{x}(x_{i}),\\mathbf{l}_{i-1})$  ,    $i=$   $1,\\cdot\\cdot\\cdot,n$   using a learned embedding function    $\\psi_{x}$  and a long short-term memory (LSTM;  Hochre- iter and Schmidhuber ,  1997 ) RNN   ${\\mathrm{L}S\\mathrm{TM}_{x}}$  . The instruction representation is  $\\bar{\\mathbf{x}}=\\mathbf{l}_{n}$  . \nWe generate the probability distribution    $P_{g}$   over pixels in    ${\\bf F}_{0}$   using L ING UN ET . The architecture of L ING UN ET  is inspired by the U-N ET  image generation method ( Ronneberger et al. ,  2015 ), ex- cept that the reconstruction phase is conditioned on the natural language instruction. L ING UN ET ﬁrst applies    $m$   convolutional layers to generate a sequence of feature maps    $\\mathbf{F}_{j}~=~\\mathbf{CNN}_{j}\\big(\\mathbf{F}_{j-1}\\big).$  ,  $j=1\\ldots m$  , where each   $\\mathbf{CN}_{j}$   is a convolutional layer with leaky ReLU non-linearities ( Maas et al. , 2013 ) and instance normalization ( Ulyanov et al. , 2016 ). The instruction representation    $\\bar{\\bf x}$   is split evenly into    $m$   vectors    $\\{\\bar{\\mathbf{x}}_{j}\\}_{j=1}^{m}$  , each is used to create a  $1\\times1$   kernel    $\\mathbf{K}_{j}\\,=\\,\\mathrm{AFFINE}_{j}\\bigl(\\bar{\\mathbf{x}}_{j}\\bigr)$  , where each   $\\mathrm{AFFINE}_{j}$   is an afﬁne transformation followed by normalizing and reshaping. For each    $\\mathbf{F}_{j}$  , we apply a 2D    $1\\times1$   convolution using the text ker- nel  $\\mathbf{{K}}_{j}$   to generate a text-conditioned feature map  $\\mathbf{G}_{j}\\ =\\ \\mathrm{ConvLOLE}\\big(\\mathbf{K}_{j},\\mathbf{F}_{j}\\big)$  , where C ONVOLVE convolves the kernel over the feature map. We then perform    $m$   deconvolutions to generate a se- quence of feature maps    $\\mathbf{H}_{m},\\hdots,\\mathbf{H}_{1}$  : \n\n\n$$\n\\begin{array}{r l r}{{\\bf H}_{m}}&{{}=}&{\\mathrm{DEDONV}_{m}\\big(\\mathrm{DROPDUT}\\big({\\bf G}_{m}\\big)\\big)}\\\\ {{\\bf H}_{j}}&{{}=}&{\\mathrm{DEDONV}_{j}\\big(\\big[{\\bf H}_{j+1};{\\bf G}_{j}\\big]\\big)~.}\\end{array}\n$$\n \nD ROPOUT  is dropout regularization ( Srivastava et al. ,  2014 ) and each   $\\mathbf{DEDONV}_{j}$   is a decon- volution operation followed a leaky ReLU non- linearity and instance norm.   Finally, we gener- ate    $P_{g}$   by applying a softmax to    $\\mathbf{H}_{1}$   and an ad- ditional learned scalar bias term    $b_{g}$   to represent events where the goal is out of sight. For example, when the agent already stands in the goal position and therefore the panorama does not show it. \nWe use    $P_{g}$   to predict the goal position in the environment. We ﬁrst select the goal pixel in  $\\mathbf{F}_{0}$   as the pixel corresponding to the highest probability element in    $P_{g}$  . We then identify the corresponding 3D location    $l_{g}$   in the environment using backward camera projection, which is computed given the camera parameters and    $p_{1}$  , the agent pose at the beginning of the execution. "}
{"page": 4, "image_path": "doc_images/D18-1287_4.jpg", "ocr_text": "camera parameters and pj, the agent pose at the\nbeginning of the execution.\n\nAction Generation Given the predicted goal ly,\nwe generate actions using an RNN. At each time\nstep t, given p;, we generate the goal mask M;,\nwhich has the same shape as the observed image\nI;. The goal mask M; has a value of 1 for each\nelement that corresponds to the goal location /, in\nI;. We do not distinguish between visible or oc-\ncluded locations. All other elements are set to 0.\nWe also maintain an out-of-sight flag 0; that is set\nto 1 if (a) J, is not within the agent’s view; or (b)\nthe max scoring element in P, corresponds to bg,\nthe term for events when the goal is not visible in\nIp. Otherwise, 0; is set to 0. We compute an ac-\ntion generation hidden state y; with an RNN:\n\nye = LSTMa (AFFINEA([FLAT(Mz); 0¢]), ye—1)\n\nwhere FLAT flattens M; into a vector, AFFINE,\nis a learned affine transformation with ReLU, and\nLSTM , is an LSTM RNN. The previous hidden\nstate y;_1 was computed when generating the pre-\nvious action, and the RNN is extended gradually\nduring execution. Finally, we compute a probabil-\nity distribution over actions:\nP(ae | bg; (Lh, p1),---(Ies pe) =\nSOFTMAX(AFFINE, (yz; ¥r(t)])) ,\n\nwhere wr is a learned embedding lookup table\nfor the current time (Chaplot et al., 2018) and\nAFFINE) is a learned affine transformation.\nModel Parameters The model parameters 6 in-\nclude the parameters of the convolutions CNNo\nand the components of LINGUNET: CNN;,\nAFFINE;, and DECONV; for 7 = 1,...,m.\nIn addition we learn two affine transformations\nAFFINE, and AFFINEp, two RNNs LSTM, and\nLSTM 4, two embedding functions 7, and wr,\nand the goal distribution bias term b,. In our ex-\nperiments (Section 7), all parameters are learned\nwithout external resources.\n\n5 Learning\n\nOur modeling decomposition enables us to choose\ndifferent learning algorithms for the two parts.\nWhile reinforcement learning is commonly de-\nployed for tasks that benefit from exploration (e.g.,\nPeters and Schaal, 2008; Mnih et al., 2013), these\nmethods require many samples due to their high\nsample complexity. However, when learning with\nnatural language, only a relatively small number\nof samples is realistically available. This problem\n\nwas addressed in prior work by learning in a con-\ntextual bandit setting (Misra et al., 2017) or mix-\ning reinforcement and supervised learning (Xiong\net al., 2018). Our decomposition uniquely offers\nto tease apart the language understanding prob-\nlem and address it with supervised learning, which\ngenerally has lower sample complexity. For action\ngeneration though, where exploration can be au-\ntonomous, we use policy gradient in a contextual\nbandit setting (Misra et al., 2017).\n\nWe assume access to training data with N ex-\namples {(#, 3, )N,, where &© is an in-\nstruction, sy is a Start state, and 3? is the goal\nstate. We train the goal prediction component by\nminimizing the cross-entropy of the predicted dis-\ntribution with the gold-standard goal distribution.\nThe gold-standard goal distribution is a determin-\nistic distribution with probability one at the pixel\ncorresponding to the goal location if the goal is in\nhe field of view, or probability one at the extra\nout-of-sight position otherwise. The gold location\nis the agent’s location in sf). We update the model\nparameters using Adam (Kingma and Ba, 2014).\nWe train action generation by maximizing the\nexpected immediate reward the agent observes\nwhile exploring the environment. The objective\n‘or a single example 7 and time stamp t is:\n\nT= So x(a] 5)R (8,0) + AA (mC. | &)) ,\nacA\nwhere R® : S x A — R is an example-specific\n\nreward function, H(-) is an entropy regularization\nterm, and \\ is the regularization coefficient. The\nreward function R® details are described in de-\ntails in Appendix B. Roughly speaking, the re-\nward function includes two additive components:\na problem reward and a shaping term (Ng et al.,\n1999). The problem reward provides a positive re-\nward for successful task completion, and a nega-\ntive reward for incorrect completion or collision.\nThe shaping term is positive when the agent gets\ncloser to the goal position, and negative if it is\nmoving away. The gradient of the objective is:\nVJ = Ss a(a | 5)V log x(a | 5) R(s¢, a)\nacA\n+AVA(r(. | St) -\n\nWe approximate the gradient by sampling an ac-\ntion using the policy (Williams, 1992), and use the\ngold goal location computed from sf), We per-\nform several parallel rollouts to compute gradients\nand update the parameters using Hogwild! (Recht\n\net al., 2011) and Adam learning rates.\n\n2671\n", "vlm_text": "\nAction Generation Given the predicted goal  $l_{g}$  , we generate actions using an RNN. At each time step    $t$  , given    $p_{t}$  , we generate the goal mask  $\\mathbf{M}_{t}$  , which has the same shape as the observed image  $\\mathbf{I}_{t}$  . The goal mask    $\\mathbf{M}_{t}$   has a value of  1  for each element that corresponds to the goal location  $l_{g}$   in  $\\mathbf{I}_{t}$  . We do not distinguish between visible or oc- cluded locations. All other elements are set to  0 . We also maintain an out-of-sight ﬂag    $o_{t}$   that is set to  1  if (a)    $l_{g}$   is not within the agent’s view; or (b) the max scoring element in    $P_{g}$   corresponds to    $b_{g}$  , the term for events when the goal is not visible in  ${\\bf\\cal I}_{P}$  . Otherwise,    $o_{t}$   is set to  0 . We compute an ac- tion generation hidden state  $y_{t}$   with an RNN: \n\n$$\ny_{t}=\\mathrm{LSTM}_{A}\\left(\\mathrm{AFM}_{A}\\big(\\big[\\mathrm{Leftarrow}_{A}\\big(\\big[\\mathrm{Leftarrow}_{t}\\big);o_{t}\\big]\\big),y_{t-1}\\right)\n$$\n \nwhere F LAT  ﬂattens    $\\mathbf{M}_{t}$   into a vector,   $\\mathbf{A}\\mathbf{F}\\mathbf{F}\\mathbf{N}\\mathbf{E}_{A}$  is a learned afﬁne transformation with ReLU, and  $\\mathrm{{LSTM}}_{A}$   is an LSTM RNN. The previous hidden state  $y_{t-1}$   was computed when generating the pre- vious action, and the RNN is extended gradually during execution. Finally, we compute a probabil- ity distribution over actions: \n\n$$\n\\begin{array}{r l}{P(a_{t}\\mid l_{g},(\\mathbf{I}_{1},p_{1}),\\dots,(\\mathbf{I}_{t},p_{t}))}&{=}\\\\ {\\mathrm{SofTMAX}(\\mathrm{AFHINE}_{p}([y_{t};\\psi_{T}(t)]))}&{,}\\end{array}\n$$\n \nwhere    $\\psi_{T}$   is a learned embedding lookup table for the current time ( Chaplot et al. ,  2018 ) and  $\\mathrm{AFINE}_{p}$   is a learned afﬁne transformation. \nModel Parameters The model parameters    $\\theta$  in- clude the parameters of the convolutions   $\\mathbf{CNN}_{0}$  and the components of L ING UN ET :  $\\mathbf{CN}_{j}$  ,  $\\mathbf{A}\\mathbf{F}\\mathbf{I}\\mathbf{N}\\mathbf{E}_{j}$  , and   $\\mathbf{DEDONV}_{j}$   for    $\\begin{array}{c c l}{j}&{=}&{1,\\ldots,m}\\end{array}$  . In addition we learn two afﬁne transformations\n\n  $\\mathbf{A}\\mathbf{F}\\mathbf{F}\\mathbf{N}\\mathbf{E}_{A}$   $\\mathrm{AFINE}_{p}$  , two RNNs   ${\\mathrm{L}S\\mathrm{TM}_{x}}$   and\n\n  $\\mathrm{{LSTM}}_{A}$  , two embedding functions    $\\psi_{x}$   and    $\\psi_{T}$  , and the goal distribution bias term    $b_{g}$  . In our ex- periments (Section  7 ), all parameters are learned without external resources. \n5 Learning \nOur modeling decomposition enables us to choose different learning algorithms for the two parts. While reinforcement learning is commonly de- ployed for tasks that beneﬁt from exploration (e.g., Peters and Schaal ,  2008 ;  Mnih et al. ,  2013 ), these methods require many samples due to their high sample complexity. However, when learning with natural language, only a relatively small number of samples is realistically available. This problem was addressed in prior work by learning in a con- textual bandit setting ( Misra et al. ,  2017 ) or mix- ing reinforcement and supervised learning ( Xiong et al. ,  2018 ). Our decomposition uniquely offers to tease apart the language understanding prob- lem and address it with supervised learning, which generally has lower sample complexity. For action generation though, where exploration can be au- tonomous, we use policy gradient in a contextual bandit setting ( Misra et al. ,  2017 ). \n\nWe assume access to training data with    $N$   ex- amples  {  $\\{(\\bar{x}^{(i)},s_{1}^{(i)},s_{g}^{(i)})\\}_{i=1}^{N}$  } , where    $\\bar{x}^{(i)}$    is an in- struction,    $s_{1}^{(i)}$  is a start state, and    $s_{g}^{(i)}$  is the goal state. We train the goal prediction component by minimizing the cross-entropy of the predicted dis- tribution with the gold-standard goal distribution. The gold-standard goal distribution is a determin- istic distribution with probability one at the pixel corresponding to the goal location if the goal is in the ﬁeld of view, or probability one at the extra out-of-sight position otherwise. The gold location is the agent’s location in    $s_{g}^{(i)}$  . We update the model parameters using Adam ( Kingma and Ba ,  2014 ). \nWe train action generation by maximizing the expected immediate reward the agent observes while exploring the environment. The objective for a single example  $i$   and time stamp  $t$   is: \n\n$$\nJ=\\sum_{a\\in\\mathcal{A}}\\pi(a\\mid\\tilde{s}_{t})R^{(i)}(s_{t},a)+\\lambda H\\big(\\pi(.\\mid\\tilde{s}_{t})\\big)\\enspace,\n$$\n \nwhere    $R^{(i)}:\\mathcal{S}\\times\\mathcal{A}\\rightarrow\\mathbb{R}$   is an example-speciﬁc reward function,    $H(\\cdot)$   is an entropy regularization term, and    $\\lambda$   is the regularization coefﬁcient. The reward function    $R^{(i)}$    details are described in de- tails in Appendix  B . Roughly speaking, the re- ward function includes two additive components: a problem reward and a shaping term (  $\\mathrm{Mg}$   et al. , 1999 ). The problem reward provides a positive re- ward for successful task completion, and a nega- tive reward for incorrect completion or collision. The shaping term is positive when the agent gets closer to the goal position, and negative if it is moving away. The gradient of the objective is: \n\n$$\n\\begin{array}{r c l}{{\\nabla J}}&{{=}}&{{\\displaystyle\\sum_{a\\in\\mathcal{A}}\\pi(a\\mid\\tilde{s}_{t})\\nabla\\log\\pi(a\\mid\\tilde{s}_{t})R(s_{t},a)}}\\\\ {{}}&{{}}&{{}}\\\\ {{}}&{{}}&{{+\\lambda\\nabla H(\\pi(.\\mid\\tilde{s}_{t})\\enspace.}}\\end{array}\n$$\n \nWe approximate the gradient by sampling an ac- tion using the policy ( Williams ,  1992 ), and use the gold goal location computed from    $s_{g}^{(i)}$  . We per- form several parallel rollouts to compute gradients and update the parameters using Hogwild! ( Recht et al. ,  2011 ) and Adam learning rates. "}
{"page": 5, "image_path": "doc_images/D18-1287_5.jpg", "ocr_text": "Dataset Statistic Lani | CHAI\nNumber paragraphs 6,000 | 1,596\nMean instructions per paragraph 4.7 7.70\nMean actions per instruction 24.6 54.5\n\nMean tokens per instruction 12.1 8.4\nVocabulary size 2,292 | 1,018\n\nTable 1: Summary statistics of the two corpora.\n6 Tasks and Data\n6.1 LANI\n\nThe goal of LANI is to evaluate how well an agent\ncan follow navigation instructions. The agent task\nis to follow a sequence of instructions that specify\na path in an environment with multiple landmarks.\nFigure 1 (left) shows an example instruction.\n\nThe environment is a fenced, square, grass\nfield. Each instance of the environment con-\ntains between 6-13 randomly placed landmarks,\nsampled from 63 unique landmarks. The agent\ncan take four types of discrete actions: FORWARD,\nTURNRIGHT, TURNLEFT, and STOP. The field is\nof size 50x50, the distance of the FORWARD ac-\ntion is 1.5, and the turn angle is 15°. The en-\nvironment simulator is implemented in Unity3D.\nAt each time step, the agent performs an action,\nobserves a first person view of the environment\nas an RGB image, and receives a scalar reward.\nThe simulator provides a socket API to control the\nagent and the environment.\n\nAgent performance is evaluated using two met-\nrics: task completion accuracy, and stop distance\nerror. A task is completed correctly if the agent\nstops within an aerial distance of 5 from the goal.\n\nWe collect a corpus of navigation instructions\nusing crowdsourcing. We randomly generate en-\nvironments, and generate one reference path for\neach environment. To elicit linguistically interest-\ning instructions, reference paths are generated to\npass near landmarks. We use Amazon Mechanical\nTurk, and split the annotation process to two tasks.\nFirst, given an environment and a reference path,\na worker writes an instruction paragraph for fol-\nlowing the path. The second task requires another\nworker to control the agent to perform the instruc-\ntions and simultaneously mark at each point what\npart of the instruction was executed. The record-\ning of the second worker creates the final data of\nsegmented instructions and demonstrations. The\ngenerated reference path is displayed in both tasks.\nThe second worker could also mark the paragraph\nas invalid. Both tasks are done from an over-\nhead view of the environment, but workers are in-\nstructed to provide instructions for a robot that ob-\n\nGo around the pillar on the right hand side] {and head\ntowards the boat, circling around it clockwise.| [When\nyou are facing the tree, walk towards it, and the pass on\nthe right hand side,] [and the left hand side of the cone.\nCircle around the cone,] [and then walk past the hydrant\non your right,| [and the the tree stump.] [Circle around\nthe stump and then stop right behind it.\n\nFigure 3: Segmented instructions in the LANI domain.\nThe original reference path is marked in red (start) and\nblue (end). The agent, using a drone icon, is placed at\nthe beginning of the path. The follower path is coded in\ncolors to align to the segmented instruction paragraph.\n\nserves the environment from a first person view.\nFigure 3 shows a reference path and the written\ninstruction. This data can be used for evaluating\nboth executing sequences of instructions and sin-\ngle instructions in isolation.\n\nTable | shows the corpus statistics.* Each para-\ngraph corresponds to a single unique instance of\nthe environment. The paragraphs are split into\ntrain, test, and development, with a 70% / 15% /\n15% split. Finally, we sample 200 single devel-\nopment instructions for qualitative analysis of the\nlanguage challenge the corpus presents (Table 2).\n\n6.2 CHAI\n\nThe CHAI corpus combines both navigation and\nsimple manipulation in a complex, simulated\nhousehold environment. We use the CHALET sim-\nulator (Yan et al., 2018), a 3D house simulator\nthat provides multiple houses, each with multi-\nple rooms. The environment supports moving be-\ntween rooms, picking and placing objects, and\nopening and closing cabinets and similar contain-\ners. Objects can be moved between rooms and\nin and out of containers. The agent observes the\nworld in first-person view, and can take five ac-\ntions: FORWARD, TURNLEFT, TURNRIGHT, STOP,\nand INTERACT. The INTERACT action acts on ob-\njects. It takes as argument a 2D position in the\nagent’s view. Agent performance is evaluated with\ntwo metrics: (a) stop distance, which measures the\ndistance of the agent’s final state to the final an-\nnotated position; and (b) manipulation accuracy,\nwhich compares the set of manipulation actions\n\n4 Appendix A provides statistics for related datasets.\n\n2672\n", "vlm_text": "The table provides various statistics comparing two datasets named \"LANI\" and \"CHAI.\" Here are the statistics presented for each dataset:\n\n1. **Number paragraphs**: \n   - LANI has 6,000 paragraphs.\n   - CHAI has 1,596 paragraphs.\n\n2. **Mean instructions per paragraph**: \n   - LANI has an average of 4.7 instructions per paragraph.\n   - CHAI has an average of 7.70 instructions per paragraph.\n\n3. **Mean actions per instruction**: \n   - LANI has an average of 24.6 actions per instruction.\n   - CHAI has an average of 54.5 actions per instruction.\n\n4. **Mean tokens per instruction**: \n   - LANI has an average of 12.1 tokens per instruction.\n   - CHAI has an average of 8.4 tokens per instruction.\n\n5. **Vocabulary size**:\n   - LANI has a vocabulary size of 2,292.\n   - CHAI has a vocabulary size of 1,018.\nTable 1: Summary statistics of the two corpora. \n6 Tasks and Data \n6.1 L ANI \nThe goal of L ANI  is to evaluate how well an agent can follow navigation instructions. The agent task is to follow a sequence of instructions that specify a path in an environment with multiple landmarks. Figure  1  (left) shows an example instruction. \nThe environment is a fenced, square, grass ﬁeld. Each instance of the environment con- tains between 6–13 randomly placed landmarks, sampled from 63 unique landmarks. The agent can take four types of discrete actions:  FORWARD , TURNRIGHT ,  TURNLEFT , and  STOP . The ﬁeld is of size   $50\\!\\times\\!50$  , the distance of the RWARD  ac- tion is 1.5, and the turn angle is 15 . The en- vironment simulator is implemented in Unity3D. At each time step, the agent performs an action, observes a ﬁrst person view of the environment as an RGB image, and receives a scalar reward. The simulator provides a socket API to control the agent and the environment. \nAgent performance is evaluated using two met- rics: task completion accuracy, and stop distance error. A task is completed correctly if the agent stops within an aerial distance of  5  from the goal. \nWe collect a corpus of navigation instructions using crowdsourcing. We randomly generate en- vironments, and generate one reference path for each environment. To elicit linguistically interest- ing instructions, reference paths are generated to pass near landmarks. We use Amazon Mechanical Turk, and split the annotation process to two tasks. First, given an environment and a reference path, a worker writes an instruction paragraph for fol- lowing the path. The second task requires another worker to control the agent to perform the instruc- tions and simultaneously mark at each point what part of the instruction was executed. The record- ing of the second worker creates the ﬁnal data of segmented instructions and demonstrations. The generated reference path is displayed in both tasks. The second worker could also mark the paragraph as invalid. Both tasks are done from an over- head view of the environment, but workers are in- structed to provide instructions for a robot that ob- \nThe image depicts a virtual environment resembling a fenced rectangular field with a variety of 3D objects placed within it. The objects include a red British-style telephone booth, a small wooden hut, a red fire hydrant, a stack of crates or barrels, a palm tree, and other miscellaneous items. The perimeter is fenced with alternating red, yellow, and blue sections. There is also a path marked out with multicolored dots (yellow, blue, purple, green, and red) that winds through the field, suggesting a route or trail set for navigation or an activity within this virtual space.\nThe image appears to display a set of instructions or a pathway described in text form, with each block of text enclosed in brackets. Each block is highlighted with different colors, such as yellow, blue, green, pink, and purple. This suggests that the instructions could be related to a navigation or movement exercise that involves moving in relation to objects like pillars, boats, trees, cones, hydrants, and tree stumps. The directions include actions like going around objects, heading towards specific items, passing on particular sides, and circling around certain landmarks. This type of instructional setup is often used in tasks related to orientation, path navigation, or obstacle courses.\nFigure 3: Segmented instructions in the L ANI  domain. The original reference path is marked in red (start) and blue (end). The agent, using a drone icon, is placed at the beginning of the path. The follower path is coded in colors to align to the segmented instruction paragraph. \nserves the environment from a ﬁrst person view. Figure  3  shows a reference path and the written instruction. This data can be used for evaluating both executing sequences of instructions and sin- Circle around the statue counter clockwise on the right hand side, gle instructions in isolation. \nTable  1  shows the corpus statistics.   Each para- white fence. graph corresponds to a single unique instance of the environment. The paragraphs are split into train, test, and development, with a    $70\\%\\mathrm{~/~}15\\%\\mathrm{~/~}$   $15\\%$   split. Finally, we sample  200  single devel- opment instructions for qualitative analysis of the language challenge the corpus presents (Table  2 ). \n6.2 C HAI \nThe C HAI  corpus combines both navigation and simple manipulation in a complex, simulated household environment. We use the C HALET  sim- ulator ( Yan et al. ,  2018 ), a 3D house simulator that provides multiple houses, each with multi- ple rooms. The environment supports moving be- tween rooms, picking and placing objects, and opening and closing cabinets and similar contain- ers. Objects can be moved between rooms and in and out of containers. The agent observes the world in ﬁrst-person view, and can take ﬁve ac- tions:  FORWARD ,  TURNLEFT ,  TURNRIGHT ,  STOP , and  INTERACT . The  INTERACT  action acts on ob- jects. It takes as argument a 2D position in the agent’s view. Agent performance is evaluated with two metrics: (a) stop distance, which measures the distance of the agent’s ﬁnal state to the ﬁnal an- notated position; and (b) manipulation accuracy, which compares the set of manipulation actions "}
{"page": 6, "image_path": "doc_images/D18-1287_6.jpg", "ocr_text": "Count\n\nCategory LANI | CHAI | Example\nSpatial relations 123 52 LANI: go to the right side of the rock\nbetween locations CHAI: pick up the cup next to the bathtub and place it on...\nConjunctions of two LANI: fly between the mushroom and the yellow cone\n\n. 36 5 . oe .\nmore locations CHAL: ... set it on the table next to the juice and milk.\nTemporal coordination 65 68 LANI: at the mushroom turn right and move forward towards the statue\nof sub-goals CHAI: go back to the kitchen and put the glass in the sink.\nSane tae tow 94 0 LANI: go past the house by the right side of the apple\n\nLANI: turn around it and move in front of fern plant\n\nCo-reference 32 18 CHAI: turn left, towards the witcha ne nt nove through it.\nComparatives ) 0 LANE: ... the small stone closest to the blue and white fences stop\n\nTable 2: Qualitative analysis of the LANI and CHAI corpora. We sample 200 single development instructions from\neach corpora. For each category, we count how many examples of the 200 contained it and show an example.\n\nScenario\n\nYou have several hours before guests begin to arrive for\na dinner party. You are preparing a wide variety of meat\ndishes, and need to put them in the sink. In addition,\nyou want to remove things in the kitchen, and bathroom\nwhich you don’t want your guests seeing, like the soaps\nin the bathroom, and the dish cleaning items. You can\nput these in the cupboards. Finally, put the dirty dishes\naround the house in the dishwasher and close it.\n\nWritten Instructions\n\n[In the kitchen, open the cupboard above the sink.| [Put\nthe cereal, the sponge, and the dishwashing soap into the\ncupboard above the sink.] [Close the cupboard.] [Pick\nup the meats and put them into the sink.] [Open the dish-\nwasher, grab the dirty dishes on the counter, and put the\ndishes into the dishwasher.\n\nFigure 4: Scenario and segmented instruction from the\nCHAI corpus.\n\nto a reference set. When measuring distance, to\nconsider the house plan, we compute the minimal\naerial distance for each room that must be visited.\nYan et al. (2018) provides the full details of the\nsimulator and evaluation. We use five different\nhouses, each with up to six rooms. Each room\ncontains on average 30 objects. A typical room\nis of size 6x6. We set the distance of FORWARD to\n0.1, the turn angle to 90°, and divide the agent’s\nview to a 3232 grid for the INTERACT action.\nWe collected a corpus of navigation and ma-\nnipulation instructions using Amazon Mechanical\nTurk. We created 36 common household scenar-\nios to provide a familiar context to the task.> We\nuse two crowdsourcing tasks. First, we provide\nworkers with a scenario and ask them to write in-\nstructions. The workers are encouraged to explore\nthe environment and interact with it. We then seg-\nment the instructions to sentences automatically.\nIn the second task, workers are presented with the\nsegmented sentences in order and asked to execute\nthem. After finishing a sentence, the workers re-\n\n5We observed that asking workers to simply write instruc-\ntions without providing a scenario leads to combinations of\nrepetitive instructions unlikely to occur in reality.\n\nquest the next sentence. The workers do not see\nthe original scenario. Figure 4 shows a scenario\nand the written segmented paragraph. Similar to\nLANI, CHAI data can be used for studying com-\nplete paragraphs and single instructions.\n\nTable 1 shows the corpus statistics.° The para-\ngraphs are split into train, test, and development,\nwith a 70% / 15% / 15% split. Table 2 shows qual-\nitative analysis of a sample of 200 instructions.\n\n7 Experimental Setup\n\nMethod Adaptations for CHAI We apply two\nmodifications to our model to support interme-\ndiate goal for the CHAI instructions. — First,\nwe train an additional RNN to predict the se-\nquence of intermediate goals given the instruc-\ntion only. There are two types of goals:\nNAVIGATION, for action sequences requiring\nmovement only and ending with the STOP action;\nand INTERACTION, for sequence of movement ac-\ntions that end with an INTERACT action. For ex-\nample, for the instruction pick up the red book\nand go to the kitchen, the sequence of goals will\nbe (INTERACTION, NAVIGATION, NAVIGATION).\nThis indicates the agent must first move to the\nobject to pick it up via interaction, move to the\nkitchen door, and finally move within the kitchen.\nThe process of executing an instruction starts with\npredicting the sequence of goal types. We call our\nmodel (Section 4) separately for each goal type.\nThe execution concludes when the final goal is\ncompleted. For learning, we create a separate ex-\nample for each intermediate goal and train the ad-\nditional RNN separately. The second modification\nis replacing the backward camera projection for\ninferring the goal location with ray casting to iden-\n\n°The number of actions per instruction is given in the\nmore fine-grained action space used during collection. To\nmake the required number of actions smaller, we use the more\ncoarse action space specified.\n\n2673\n", "vlm_text": "This table presents data on different linguistic categories, specifically in the context of spatial language or navigation instructions. It is organized into four columns: \"Category,\" \"Count\" for two systems (LANI and CHAI), and \"Example.\"\n\nHere's a summary of the content:\n\n1. **Category**: This column lists various categories related to navigation instructions, such as spatial relations, conjunctions, temporal coordination, trajectory constraints, co-reference, and comparatives.\n\n2. **Count (LANI and CHAI)**: Under this column, the table displays the number of occurrences for each category in two different systems or datasets named LANI and CHAI.\n\n   - **Spatial relations between locations**: \n     - LANI: 123 occurrences\n     - CHAI: 52 occurrences\n\n   - **Conjunctions of two or more locations**:\n     - LANI: 36 occurrences\n     - CHAI: 5 occurrences\n\n   - **Temporal coordination of sub-goals**:\n     - LANI: 65 occurrences\n     - CHAI: 68 occurrences\n\n   - **Constraints on the shape of trajectory**:\n     - LANI: 94 occurrences\n     - CHAI: 0 occurrences\n\n   - **Co-reference**:\n     - LANI: 32 occurrences\n     - CHAI: 18 occurrences\n\n   - **Comparatives**:\n     - LANI: 2 occurrences\n     - CHAI: 0 occurrences\n\n3. **Example**: This column provides example instructions for each category, with text specific to LANI and CHAI. The examples illustrate how spatial relations, conjunctions, temporal coordination, trajectory constraints, co-reference, and comparatives are used in navigation instructions.\n\nOverall, the table provides a comparison between two systems or datasets (LANI and CHAI) in terms of how frequently certain linguistic categories appear and offers examples of how these categories are represented within navigation instructions.\nThe table contains two sections, \"Scenario\" and \"Written Instructions\":\n\n1. **Scenario**:\n   - The scenario describes a situation where you have several hours before guests arrive for a dinner party. You are preparing various meat dishes that need to be placed in the sink. Additionally, you want to remove items from the kitchen and bathroom that you don’t want your guests to see, such as soaps in the bathroom and dish cleaning items. These can be stored in the cupboards. Finally, you should put any dirty dishes around the house into the dishwasher and close it.\n\n2. **Written Instructions**:\n   - The instructions provide step-by-step tasks to follow:\n     - In the kitchen, open the cupboard above the sink.\n     - Put the cereal, sponge, and dishwashing soap into the cupboard above the sink.\n     - Close the cupboard.\n     - Pick up the meats and place them in the sink.\n     - Open the dishwasher, gather the dirty dishes from the counter, and put them into the dishwasher.\nto a reference set. When measuring distance, to consider the house plan, we compute the minimal aerial distance for each room that must be visited. Yan et al.  ( 2018 ) provides the full details of the simulator and evaluation. We use ﬁve different houses, each with up to six rooms. Each room contains on average 30 objects. A typical room is of size  $6\\!\\times\\!6$  . We set  distance of  FORWARD  to 0.1, the turn angle to 90 , and divide the agent’s view to a  $32\\!\\times\\!32$   grid for the  INTERACT  action. \nWe collected a corpus of navigation and ma- nipulation instructions using Amazon Mechanical Turk. We created 36 common household scenar- ios to provide a familiar context to the task.   We use two crowdsourcing tasks. First, we provide workers with a scenario and ask them to write in- structions. The workers are encouraged to explore the environment and interact with it. We then seg- ment the instructions to sentences automatically. In the second task, workers are presented with the segmented sentences in order and asked to execute them. After ﬁnishing a sentence, the workers re- quest the next sentence. The workers do not see the original scenario. Figure  4  shows a scenario and the written segmented paragraph. Similar to L ANI , C HAI  data can be used for studying com- plete paragraphs and single instructions. \n\nTable  1  shows the corpus statistics.   The para- graphs are split into train, test, and development, with a  $70\\%\\,/\\,15\\%\\,/\\,15\\%$   split. Table  2  shows qual- itative analysis of a sample of 200 instructions. \n7 Experimental Setup \nMethod Adaptations for C HAI We apply two modiﬁcations to our model to support interme- diate goal for the C HAI  instructions. First, we train an additional RNN to predict the se- quence of intermediate goals given the instruc- tion only. There are two types of goals: NAVIGATION , for action sequences requiring movement only and ending with the  STOP  action; and  INTERACTION , for sequence of movement ac- tions that end with an  INTERACT  action. For ex- ample, for the instruction  pick up the red book and go to the kitchen , the sequence of goals will be h INTERACTION ,  NAVIGATION ,  NAVIGATION i . This indicates the agent must ﬁrst move to the object to pick it up via interaction, move to the kitchen door, and ﬁnally move within the kitchen. The process of executing an instruction starts with predicting the sequence of goal types. We call our model (Section  4 ) separately for each goal type. The execution concludes when the ﬁnal goal is completed. For learning, we create a separate ex- ample for each intermediate goal and train the ad- ditional RNN separately. The second modiﬁcation is replacing the backward camera projection for inferring the goal location with ray casting to iden- "}
{"page": 7, "image_path": "doc_images/D18-1287_7.jpg", "ocr_text": "tify INTERACTION goals, which are often objects\nthat are not located on the ground.\n\nBaselines We compare our approach against the\nfollowing baselines: (a) STOP: Agent stops im-\nmediately; (b) RANDOMWALK: Agent samples\nactions uniformly until it exhausts the horizon\nor stops; (c) MOSTFREQUENT: Agent takes the\nmost frequent action in the data, FORWARD for\nboth datasets, until it exhausts the horizon; (d)\nMISRAI7: the approach of Misra et al. (2017);\nand (e) CHAPLOT18: the approach of Chaplot\net al. (2018). We also evaluate goal prediction and\ncompare to the method of Janner et al. (2018) and\na CENTER baseline, which always predict the cen-\nter pixel. Appendix C provides baseline details.\nEvaluation Metrics We evaluate using the met-\nrics described in Section 6: stop distance (SD) and\ntask completion (TC) for LANI, and stop distance\n(SD) and manipulation accuracy (MA) for CHAI.\nTo evaluate the goal prediction, we report the real\ndistance of the predicted goal from the annotated\ngoal and the percentage of correct predictions. We\nconsider a goal correct if it is within a distance of\n5.0 for LANI and 1.0 for CHAI. We also report\nhuman evaluation for LANI by asking raters if the\ngenerated path follows the instruction on a Likert-\ntype scale of 1-5. Raters were shown the gener-\nated path, the reference path, and the instruction.\nParameters We use a horizon of 40 for both\ndomains. During training, we allow additional\n5 steps to encourage learning even after errors.\nWhen using intermediate goals in CHAI, the hori-\nzon is used for each intermediate goal separately.\nAll other parameters and detailed in Appendix D.\n\n8 Results\n\nTables 3 and 4 show development and test re-\nsults. Both sets of experiments demonstrate sim-\nilar trends. The low performance of STOP, RAN-\nDOMWALK, and MOSTFREQUENT demonstrates\n\nLANI CHAI LANI CHAI\nMethod SD TC SD MA Method SD TC SD MA\nSTOP 15.37 | 8.20 | 2.99 | 37.53 STOP 15.18 | 8.29 | 3.59 | 39.77\nRANDOMWALK 14.80 | 9.66 | 2.99 | 28.96 RANDOMWALK 14.63 | 9.76 | 3.59 | 33.29\nMOSTFREQUENT 19.31 2.94 | 3.80 | 37.53 MOSTFREQUENT | 19.14 | 3.15 | 4.36 | 39.77\nMISRAI7 10.54 | 22.9 | 2.99 | 32.25 MISRAI7 10.23 | 23.2 | 3.59 | 36.84\nCHAPLOT18 9.05 31.0 | 2.99 | 37.53 CHAPLOT18 8.78 | 31.9 | 3.59 | 39.76\nOur Approach (OA) | 8.65 | 35.72 | 2.75 | 37.53 Our Approach 8.43 | 36.9 | 3.34 | 39.97\nOA w/o RNN 9.21 31.30 | 3.75 | 37.43 .\nOA wio Language 1065 | 2302 | 322 | 37.53 Table 4: Performance on the held-out test dataset.\nOA w/joint 11.54 | 21.76 | 2.99 | 36.90 Method = EAN = CHAT\n; lethor ist cc ist cc\nOA w/oracle goals 2.13 | 94.60 | 2.19 | 41.07 CENTER 12.0 119.51 1 341 1 19.0\n. Janner et al. (2018) | 9.61 | 30.26 | 2.81 | 28.3\nTable 3: Performance on the development data. Our Approach 367 | 3583 | 212 | 403\n\nTable 5: Development goal prediction performance.\nWe measure distance (Dist) and accuracy (Acc).\n\nthe challenges of both tasks, and shows the tasks\nare robust to simple biases. On LANI, our ap-\nproach outperforms CHAPLOT 18, improving task\ncompletion (TC) accuracy by 5%, and both meth-\nods outperform MISRA17. On CHAI, CHAP-\nLOT18 and MISRAI17 both fail to learn, while\nour approach shows an improvement on stop dis-\ntance (SD). However, all models perform poorly\non CHAI, especially on manipulation (MA).\n\nTo isolate navigation performance on CHAI, we\nlimit our train and test data to instructions that in-\nclude navigation actions only. The STOP baseline\non these instructions gives a stop distance (SD) of\n3.91, higher than the average for the entire data\nas these instructions require more movement. Our\napproach gives a stop distance (SD) of 3.24, a 17%\nreduction of error, significantly better than the 8%\nreduction of error over the entire corpus.\n\nWe also measure human performance on a sam-\nple of 100 development examples for both tasks.\nOn LANI, we observe a stop distance error (SD)\nof 5.2 and successful task completion (TC) 63%\nof the time. On CHAI, the human distance er-\nror (SD) is 1.34 and the manipulation accuracy is\n100%. The imperfect performance demonstrates\nhe inherent ambiguity of the tasks. The gap to\nhuman performance is still large though, demon-\nstrating that both tasks are largely open problems.\n\nThe imperfect human performance raises ques-\nions about automated evaluation. In general,\nwe observe that often measuring execution qual-\nity with rigid goals is insufficient. We conduct\na human evaluation with 50 development exam-\nples from LANI rating human performance and\nour approach. Figure 5 shows a histogram of the\nratings. The mean rating for human followers is\n4.38, while our approach’s is 3.78; we observe\na similar trend to before with this metric. Using\n\n2674\n", "vlm_text": "The table presents comparative results of different methods based on certain metrics evaluated across two datasets, labeled as LANI and CHAI. Each dataset is evaluated using different performance metrics: \n\n- For LANI, the metrics are SD (seemingly related to some kind of error or deviation) and TC (possibly related to task completion or a similar concept).\n- For CHAI, the metrics are SD (similar to LANI) and MA (which could denote mean accuracy or a similar measurement).\n\nThe methods compared include:\n\n1. Baseline methods:\n   - STOP\n   - RANDOMWALK\n   - MOSTFREQUENT\n\n2. Previous approaches:\n   - MISRA17\n   - CHAPLOT18\n\n3. The method proposed in this work is labeled as \"Our Approach (OA),\" and variations of this approach are also evaluated:\n   - OA w/o RNN (without Recurrent Neural Network)\n   - OA w/o Language\n   - OA w/joint\n   - OA w/oracle goals\n\nThe table highlights \"Our Approach (OA)\" in bold, indicating it might be the focus of the study, as it exhibits lower and higher performance in certain metrics compared to other methods:\n\n- For LANI, the OA achieves an SD of 8.65 and a TC of 35.72.\n- For CHAI, the OA shows an SD of 2.75.\n\nThese results indicate that the proposed method potentially performs competitively or better than other methods in the specified metrics.\ntify  INTERACTION  goals, which are often objects that are not located on the ground. \nBaselines We compare our approach against the following baselines: (a) S TOP : Agent stops im- mediately; (b) R ANDOM W ALK : Agent samples actions uniformly until it exhausts the horizon or stops; (c) M OST F REQUENT : Agent takes the most frequent action in the data,  FORWARD  for both datasets, until it exhausts the horizon; (d) M ISRA 17: the approach of  Misra et al.  ( 2017 ); and (e) C HAPLOT 18: the approach of  Chaplot et al.  ( 2018 ). We also evaluate goal prediction and compare to the method of  Janner et al.  ( 2018 ) and a C ENTER  baseline, which always predict the cen- ter pixel. Appendix  C  provides baseline details. \nEvaluation Metrics We evaluate using the met- rics described in Section  6 : stop distance (SD) and task completion (TC) for L ANI , and stop distance (SD) and manipulation accuracy (MA) for C HAI . To evaluate the goal prediction, we report the real distance of the predicted goal from the annotated goal and the percentage of correct predictions. We consider a goal correct if it is within a distance of 5 . 0  for L ANI  and  1 . 0  for C HAI . We also report human evaluation for L ANI  by asking raters if the generated path follows the instruction on a Likert- type scale of 1–5. Raters were shown the gener- ated path, the reference path, and the instruction. \nParameters We use a horizon of  40  for both domains. During training, we allow additional 5  steps to encourage learning even after errors. When using intermediate goals in C HAI , the hori- zon is used for each intermediate goal separately. All other parameters and detailed in Appendix  D . \n8Results\nTables  3  and  4  show development and test re- sults. Both sets of experiments demonstrate sim- ilar trends. The low performance of S TOP , R AN - DOM W ALK , and M OST F REQUENT  demonstrates \nThe image contains two tables summarizing the performance of various methods on a held-out test dataset. \n\nThe first table displays the results for different methods under two scenarios labeled \"LANI\" and \"CHAI\". For \"LANI\", the metrics include SD (Standard Deviation) and TC (probably Total Count or some other metric), while for \"CHAI\", the metrics are SD and MA (probably Mean Average or a similar metric). The methods assessed are STOP, RANDOMWALK, MOSTFREQUENT, MISRA17, CHAPLOT18, and \"Our Approach\". The bold values in \"Our Approach\" indicate the best performance among the listed methods for specific scenarios: \n- \"LANI\" for SD: 8.43, TC: 36.9 \n- \"CHAI\" for SD: 3.34, MA: 39.97\n\nThe second table shows the performance of three methods on the \"LANI\" and \"CHAI\" datasets, using metrics Dist (Distance) and Acc (Accuracy):\n- CENTER: LANI Dist: 12.0, Acc: 19.51; CHAI Dist: 3.41, Acc: 19.0\n- Janner et al. (2018): LANI Dist: 9.61, Acc: 30.26; CHAI Dist: 2.81, Acc: 28.3\n- \"Our Approach\": LANI Dist: 8.67, Acc: 35.83; CHAI Dist: 2.12, Acc: 40.3\n\n\"Our Approach\" demonstrates the best performance in terms of lower Dist and higher Acc compared to the other methods in both the \"LANI\" and \"CHAI\" datasets.\nthe challenges of both tasks, and shows the tasks are robust to simple biases. On L ANI , our ap- proach outperforms C HAPLOT 18, improving task completion (TC) accuracy by    $5\\%$  , and both meth- ods outperform M ISRA 17. On C HAI , C HAP - LOT 18 and M ISRA 17 both fail to learn, while our approach shows an improvement on stop dis- tance (SD). However, all models perform poorly on C HAI , especially on manipulation (MA). \nTo isolate navigation performance on C HAI , we limit our train and test data to instructions that in- clude navigation actions only. The S TOP  baseline on these instructions gives a stop distance (SD) of 3.91, higher than the average for the entire data as these instructions require more movement. Our approach gives a stop distance (SD) of 3.24, a   $17\\%$  reduction of error, signiﬁcantly better than the   $8\\%$  reduction of error over the entire corpus. \nWe also measure human performance on a sam- ple of 100 development examples for both tasks. On L ANI , we observe a stop distance error (SD) of 5.2 and successful task completion (TC)   $63\\%$  of the time. On C HAI , the human distance er- ror (SD) is 1.34 and the manipulation accuracy is  $100\\%$  . The imperfect performance demonstrates the inherent ambiguity of the tasks. The gap to human performance is still large though, demon- strating that both tasks are largely open problems. \nThe imperfect human performance raises ques- tions about automated evaluation. In general, we observe that often measuring execution qual- ity with rigid goals is insufﬁcient. We conduct a human evaluation with 50 development exam- ples from L ANI  rating human performance and our approach. Figure  5  shows a histogram of the ratings. The mean rating for human followers is 4.38, while our approach’s is 3.78; we observe a similar trend to before with this metric. Using "}
{"page": 8, "image_path": "doc_images/D18-1287_8.jpg", "ocr_text": "Category Present | Absent | p-value\nSpatial relations 8.75 10.09 262\nLocation conjunction 10.19 9.05 327\nTemporal coordination 11.38 8.24 O15\nTrajectory constraints 9.56 8.99 607\nCo-reference 12.88 8.59 016\nComparatives 10.22 9.25 906\n\nTable 6: Mean goal prediction error for LANI instruc-\ntions with and without the analysis categories we used\n\nin Table 2. The p-values are from two-sided t-tests\ncomparing the means in each row.\n60\n\nSo 40 Oo Human\n\ng 00 Our Approach\n\n2 20\n\nBy\n\na 0\n\n1 2 3 4 5\n\nFigure 5: Likert rating histogram for expert human fol-\nlower and our approach for LANI.\n\njudgements on our approach, we correlate the hu-\nman metric with the SD measure. We observe a\nPearson correlation -0.65 (p=5e-7), indicating that\nour automated metric correlates well with human\njudgment.’ This initial study suggests that our au-\ntomated evaluation is appropriate for this task.\n\nOur ablations (Table 3) demonstrate the impor-\ntance of each of the components of the model.\nWe ablate the action generation RNN (w/o RNN),\ncompletely remove the language input (w/o Lan-\nguage), and train the model jointly (w/joint Learn-\ning)... On CHAI especially, ablations results in\nmodels that display ineffective behavior. Of the\nablations, we observe the largest benefit from\ndecomposing the learning and using supervised\nlearning for the language problem.\n\nWe also evaluate our approach with access to\noracle goals (Table 3). We observe this im-\nproves navigation performance significantly on\nboth tasks. However, the model completely fails\nto learn a reasonable manipulation behavior for\nCHAI. This illustrates the planning complexity\nof this domain. A large part of the improvement\nin measured navigation behavior is likely due to\neliminating much of the ambiguity the automated\nmetric often fails to capture.\n\nFinally, on goal prediction (Table 5), our ap-\nproach outperforms the method of Janner et al.\n(2018). Figure 6 and Appendix Figure 7 show ex-\nample goal predictions. In Table 6, we break down\nLANI goal prediction results for the analysis cate-\n\n7We did not observe this kind of clear anti-correlation\ncomparing the two results for human performance (Pearson\ncorrelation of 0.09 and p=0.52). The limited variance in hu-\nman performance makes correlation harder to test.\n\n8 Appendix C provides the details of joint learning.\n\ncurve around big rock keeping it to your left .\n\nwalk over to the cabinets and open the cabinet doors up\n\nFigure 6: Goal prediction probability maps P, overlaid\non the corresponding observed panoramas Ip. The top\nexample shows a result on LANI, the bottom on CHAI.\ngories we used in Table 2 using the same sample of\nthe data. Appendix E includes a similar table for\nCHAI. We observe that our approach finds instruc-\ntions with temporal coordination or co-reference\nchallenging. Co-reference is an expected limita-\ntion; with single instructions, the model can not\nresolve references to previous instructions.\n\n9 Discussion\n\nWe propose a model for instruction following with\nexplicit separation of goal prediction and action\ngeneration. Our representation of goal prediction\nis easily interpretable, while not requiring the de-\nsign of logical ontologies and symbolic represen-\nations. A potential limitation of our approach is\ncascading errors. Action generation relies com-\npletely on the predicted goal and is not exposed\no the language otherwise. This also suggests a\nsecond related limitation: the model is unlikely\no successfully reason about instructions that in-\nclude constraints on the execution itself. While\nhe model may reach the final goal correctly, it is\nunlikely to account for the intermediate trajectory\nconstraints. As we show (Table 2), such instruc-\nions are common in our data. These two limita-\nions may be addressed by allowing action genera-\nion access to the instruction. Achieving this while\nretaining an interpretable goal representation that\nclearly determines the execution is an important\ndirection for future work. Another important open\nquestion concerns automated evaluation, which re-\nmains especially challenging when instructions do\nnot only specify goals, but also constraints on how\nto achieve them. Our resources provide the plat-\nform and data to conduct this research.\nAcknowledgments\n\nThis research was supported by NSF (CRII-\n1656998), Schmidt Sciences, and cloud com-\nputing credits from Microsoft. We thank John\nLangford, Claudia Yan, Bharath Hariharan, Noah\nSnavely, the Cornell NLP group, and the anony-\nmous reviewers for their advice.\n\n2675\n", "vlm_text": "This table presents data on different linguistic or semantic categories, comparing two groups: \"Present\" and \"Absent.\" It also includes a p-value for each category, likely indicating the statistical significance of the difference between the \"Present\" and \"Absent\" groups. Here's a breakdown of the table:\n\n- **Categories**: Various types of linguistic or semantic features\n  - Spatial relations\n  - Location conjunction\n  - Temporal coordination\n  - Trajectory constraints\n  - Co-reference\n  - Comparatives\n\n- **Present**: The average or observed value when the category is present\n  - Spatial relations: 8.75\n  - Location conjunction: 10.19\n  - Temporal coordination: 11.38\n  - Trajectory constraints: 9.56\n  - Co-reference: 12.88\n  - Comparatives: 10.22\n  \n- **Absent**: The average or observed value when the category is absent\n  - Spatial relations: 10.09\n  - Location conjunction: 9.05\n  - Temporal coordination: 8.24\n  - Trajectory constraints: 8.99\n  - Co-reference: 8.59\n  - Comparatives: 9.25\n\n- **p-value**: Indicates the statistical significance of differences between \"Present\" and \"Absent\" groups\n  - Spatial relations: .262\n  - Location conjunction: .327\n  - Temporal coordination: .015\n  - Trajectory constraints: .607\n  - Co-reference: .016\n  - Comparatives: .906\n\nA lower p-value (typically less than 0.05) suggests that the difference between the \"Present\" and \"Absent\" groups is statistically significant. In this table, \"Temporal coordination\" and \"Co-reference\" show statistically significant differences, suggesting meaningful differences between \"Present\" and \"Absent\" groups for these categories.\nTable 6: Mean goal prediction error for L ANI  instruc- tions with and without the analysis categories we used in Table  2 . The    $p$  -values are from two-sided    $t$  -tests comparing the means in each row. \nThe image is a histogram illustrating the distribution of Likert scale ratings for two entities: \"Human\" and \"Our Approach\" concerning L ANI. The Likert scale ranges from 1 to 5 on the x-axis, and the y-axis represents the percentage of responses.\n\n- The blue bars represent the ratings for \"Human,\" while the red bars represent the ratings for \"Our Approach.\"\n- At rating 1, both \"Human\" and \"Our Approach\" have very low percentages, almost negligible.\n- Rating 2 shows a slightly higher percentage for \"Our Approach\" compared to \"Human.\"\n- At rating 3, both \"Human\" and \"Our Approach\" show moderate percentages.\n- Rating 4 has a notable percentage for \"Human,\" whereas \"Our Approach\" is slightly lower.\n- Rating 5 has the highest percentage for both \"Human\" and \"Our Approach,\" with \"Our Approach\" having a higher percentage than \"Human.\"\n\nOverall, the histogram shows how both entities are rated across a 5-point Likert scale, indicating the distribution and preference for each rating.\njudgements on our approach, we correlate the hu- man metric with the SD measure. We observe a Pearson correlation -0.65   $(\\mathrm{p{=}}5\\mathrm{e{-}}7)$  ), indicating that our automated metric correlates well with human judgment.   This initial study suggests that our au- tomated evaluation is appropriate for this task. \nOur ablations (Table  3 ) demonstrate the impor- tance of each of the components of the model. We ablate the action generation RNN (w/o RNN), completely remove the language input (w/o Lan- guage), and train the model jointly (w/joint Learn- ing). On C HAI  especially, ablations results in models that display ineffective behavior. Of the ablations, we observe the largest beneﬁt from decomposing the learning and using supervised learning for the language problem. \nWe also evaluate our approach with access to oracle goals (Table  3 ). We observe this im- proves navigation performance signiﬁcantly on both tasks. However, the model completely fails to learn a reasonable manipulation behavior for C HAI . This illustrates the planning complexity of this domain. A large part of the improvement in measured navigation behavior is likely due to eliminating much of the ambiguity the automated metric often fails to capture. \nFinally, on goal prediction (Table  5 ), our ap- proach outperforms the method of  Janner et al. ( 2018 ). Figure  6  and Appendix Figure  7  show ex- ample goal predictions. In Table  6 , we break down L ANI  goal prediction results for the analysis cate- \nThe image contains two main sections with text captions. The first section is a panoramic outdoor scene with grass and a fenced area, showing a heat map effect in the middle. The caption for this section reads \"curve around big rock keeping it to your left.\" \n\nThe second section shows an indoor scene, specifically a large kitchen area with counters, cabinets, and various appliances, including a refrigerator, and a door labeled \"living room.\" There is a heat map effect over the kitchen cabinets. The caption associated with the overall image says \"walk over to the cabinets and open the cabinet doors up.\"\n9 Discussion \nWe propose a model for instruction following with explicit separation of goal prediction and action generation. Our representation of goal prediction is easily interpretable, while not requiring the de- sign of logical ontologies and symbolic represen- tations. A potential limitation of our approach is cascading errors. Action generation relies com- pletely on the predicted goal and is not exposed to the language otherwise. This also suggests a second related limitation: the model is unlikely to successfully reason about instructions that in- clude constraints on the execution itself. While the model may reach the ﬁnal goal correctly, it is unlikely to account for the intermediate trajectory constraints. As we show (Table  2 ), such instruc- tions are common in our data. These two limita- tions may be addressed by allowing action genera- tion access to the instruction. Achieving this while retaining an interpretable goal representation that clearly determines the execution is an important direction for future work. Another important open question concerns automated evaluation, which re- mains especially challenging when instructions do not only specify goals, but also constraints on how to achieve them. Our resources provide the plat- form and data to conduct this research. \nAcknowledgments \nThis research was supported by NSF (CRII- 1656998), Schmidt Sciences, and cloud com- puting credits from Microsoft. We thank John Langford, Claudia Yan, Bharath Hariharan, Noah Snavely, the Cornell NLP group, and the anony- mous reviewers for their advice. "}
{"page": 9, "image_path": "doc_images/D18-1287_9.jpg", "ocr_text": "References\n\nAnne H Anderson, Miles Bader, Ellen Gurman Bard,\nElizabeth Boyle, Gwyneth Doherty, Simon Garrod,\nStephen Isard, Jacqueline Kowtko, Jan McAllister,\nJim Miller, Catherine Sotillo, Henry S. Thompson,\nand Regina Weinert. 1991. The HCRC map task\ncorpus. Language and Speech, 34.\n\nPeter Anderson, Qi Wu, Damien Teney, Jake Bruce,\nMark Johnson, Niko Siinderhauf, Ian Reid, Stephen\nGould, and Anton van den Hengel. 2018. Vision-\nand-language navigation: Interpreting visually-\ngrounded navigation instructions in real environ-\nments. In Proceedings of the IEEE Conference on\nComputer Vision and Pattern Recognition.\n\nYoav Artzi, Dipanjan Das, and Slav Petrov. 2014.\nLearning compact lexicons for CCG semantic pars-\ning. In Proceedings of the 2014 Conference on Em-\npirical Methods in Natural Language Processing.\n\nYoav Artzi and Luke Zettlemoyer. 2013. Weakly su-\npervised learning of semantic parsers for mapping\ninstructions to actions. Transactions of the Associa-\ntion of Computational Linguistics, 1.\n\nYonatan Bisk, Daniel Marcu, and William Wong. 2016.\nTowards a dataset for human computer communica-\ntion via grounded language acquisition. In Proceed-\nings of the AAAI Workshop on Symbiotic Cognitive\nSystems.\n\nDevendra Singh Chaplot, Kanthashree Mysore\nSathyendra, Rama Kumar Pasumarthi, Dheeraj\nRajagopal, and Ruslan Salakhutdinov. 2018. Gated-\nattention architectures for task-oriented language\ngrounding.\n\nDavid L. Chen and Raymond J. Mooney. 2011. Learn-\ning to interpret natural language navigation instruc-\ntions from observations. In Proceedings of the Na-\ntional Conference on Artificial Intelligence.\n\nDeborah A Dahl, Madeleine Bates, Michael Brown,\nWilliam Fisher, Kate Hunicke-Smith, David Pallett,\nChristine Pao, Alexander Rudnicky, and Elizabeth\nShriberg. 1994. Expanding the scope of the ATIS\ntask: The ATIS-3 corpus. In Proceedings of the\nworkshop on Human Language Technology.\n\nAbhishek Das, Samyak Datta, Georgia Gkioxari, Ste-\nfan Lee, Devi Parikh, and Dhruv Batra. 2018. Em-\nbodied question answering. In Proceedings of the\nIEEE Conference on Computer Vision and Pattern\nRecognition.\n\nDaniel Fried, Ronghang Hu, Volkan Cirik, Anna\nRohrbach, Jacob Andreas, Louis-Philippe Morency,\nTaylor Berg-Kirkpatrick, Kate Saenko, Dan Klein,\nand Trevor Darrell. 2018. Speaker-follower mod-\nels for vision-and-language navigation. CoRR,\nabs/1806.02724.\n\nDaniel Gordon, Aniruddha Kembhavi, Mohammad\nRastegari, Joseph Redmon, Dieter Fox, and Ali\n\nFarhadi. 2018. Iqa: Visual question answering in in-\nteractive environments. In Proceedings of the IEEE\nConference on Computer Vision and Pattern Recog-\nnition.\n\nCharles T. Hemphill, John J. Godfrey, and George R.\nDoddington. 1990. The ATIS spoken language sys-\ntems pilot corpus. In Proceedings of the DARPA\nspeech and natural language workshop.\n\nKarl Moritz Hermann, Felix Hill, Simon Green, Fumin\nWang, Ryan Faulkner, Hubert Soyer, David Szepes-\nvari, Wojciech Czarnecki, Max Jaderberg, Denis\nTeplyashin, Marcus Wainwright, Chris Apps, Demis\nHassabis, and Phil Blunsom. 2017. Grounded lan-\nguage learning in a simulated 3D world. CoRR,\nabs/1706.06551.\n\nSepp Hochreiter and Jiirgen Schmidhuber. 1997. Long\nshort-term memory. Neural computation, 9.\n\nMichael Janner, Karthik Narasimhan, and Regina\nBarzilay. 2018. Representation learning for\ngrounded spatial reasoning. Transactions of the As-\nsociation for Computational Linguistics, 6.\n\nSahar Kazemzadeh, Vicente Ordonez, Mark Matten,\nand Tamara L. Berg. 2014. Referitgame: Referring\nto objects in photographs of natural scenes. In Pro-\nceedings of the Conference on Empirical Methods in\nNatural Language Processing.\n\nJoohyun Kim and Raymond Mooney. 2012. Unsuper-\nvised PCFG induction for grounded language learn-\ning with highly ambiguous supervision. In Proceed-\nings of the Joint Conference on Empirical Methods\nin Natural Language Processing and Computational\nNatural Language Learning.\n\nDiederik Kingma and Jimmy Ba. 2014. Adam: A\nmethod for stochastic optimization. In Proceedings\nof the International Conference on Learning Repre-\nsentations.\n\nNikita Kitaev and Dan Klein. 2017. Where is misty?\ninterpreting spatial descriptors by modeling regions\nin space. In Proceedings of the Conference on Em-\npirical Methods in Natural Language Processing.\n\nChen Kong, Dahua Lin, Mohit Bansal, Raquel Urta-\nsun, and Sanja Fidler. 2014. What are you talking\nabout? text-to-image coreference. In Proceedings of\nthe IEEE Conference on Computer Vision and Pat-\ntern Recognition.\n\nJayant Krishnamurthy and T. Kollar. 2013. Jointly\nlearning to parse and perceive: Connecting natural\nlanguage to the physical world. Transactions of the\nAssociation for Computational Linguistics, 1.\n\nYann LeCun, Léon Bottou, Yoshua Bengio, and Patrick\nHaffner. 1998. Gradient-based learning applied to\ndocument recognition. Proceedings of the IEEE, 86.\n\n2676\n", "vlm_text": "References \nAnne H Anderson, Miles Bader, Ellen Gurman Bard, Elizabeth Boyle, Gwyneth Doherty, Simon Garrod, Stephen Isard, Jacqueline Kowtko, Jan McAllister, Jim Miller, Catherine Sotillo, Henry S. Thompson, and Regina Weinert. 1991. The HCRC map task corpus.  Language and Speech , 34. \nPeter Anderson, Qi Wu, Damien Teney, Jake Bruce, Mark Johnson, Niko Sünderhauf, Ian Reid, Stephen Gould, and Anton van den Hengel. 2018. Vision- and-language navigation: Interpreting visually- grounded navigation instructions in real environ- ments. In  Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition . \nYoav Artzi, Dipanjan Das, and Slav Petrov. 2014. Learning compact lexicons for CCG semantic pars- ing. In  Proceedings of the 2014 Conference on Em- pirical Methods in Natural Language Processing . \nYoav Artzi and Luke Zettlemoyer. 2013. Weakly su- pervised learning of semantic parsers for mapping instructions to actions.  Transactions of the Associa- tion of Computational Linguistics , 1. \nYonatan Bisk, Daniel Marcu, and William Wong. 2016. Towards a dataset for human computer communica- tion via grounded language acquisition. In  Proceed- ings of the AAAI Workshop on Symbiotic Cognitive Systems . \nDevendra Singh Chaplot, Kanthashree Mysore Sathyendra, Rama Kumar Pasumarthi, Dheeraj Rajagopal, and Ruslan Salakhutdinov. 2018. Gated- attention architectures for task-oriented language grounding. \nDavid L. Chen and Raymond J. Mooney. 2011. Learn- ing to interpret natural language navigation instruc- tions from observations. In  Proceedings of the Na- tional Conference on Artiﬁcial Intelligence . \nDeborah A Dahl, Madeleine Bates, Michael Brown, William Fisher, Kate Hunicke-Smith, David Pallett, Christine Pao, Alexander Rudnicky, and Elizabeth Shriberg. 1994. Expanding the scope of the ATIS task: The ATIS-3 corpus. In  Proceedings of the workshop on Human Language Technology . \nAbhishek Das, Samyak Datta, Georgia Gkioxari, Ste- fan Lee, Devi Parikh, and Dhruv Batra. 2018. Em- bodied question answering. In  Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition . \nDaniel Fried, Ronghang Hu, Volkan Cirik, Anna Rohrbach, Jacob Andreas, Louis-Philippe Morency, Taylor Berg-Kirkpatrick, Kate Saenko, Dan Klein, and Trevor Darrell. 2018. Speaker-follower mod- els for vision-and-language navigation. CoRR , abs/1806.02724. \nDaniel Gordon, Aniruddha Kembhavi, Mohammad Rastegari, Joseph Redmon, Dieter Fox, and Ali \nFarhadi. 2018. Iqa: Visual question answering in in- teractive environments. In  Proceedings of the IEEE Conference on Computer Vision and Pattern Recog- nition . \nCharles T. Hemphill, John J. Godfrey, and George R. Doddington. 1990. The ATIS spoken language sys- tems pilot corpus. In  Proceedings of the DARPA speech and natural language workshop . \nKarl Moritz Hermann, Felix Hill, Simon Green, Fumin Wang, Ryan Faulkner, Hubert Soyer, David Szepes- vari, Wojciech Czarnecki, Max Jaderberg, Denis Teplyashin, Marcus Wainwright, Chris Apps, Demis Hassabis, and Phil Blunsom. 2017. Grounded lan- guage learning in a simulated 3D world. CoRR , abs/1706.06551. \nSepp Hochreiter and Jürgen Schmidhuber. 1997. Long short-term memory.  Neural computation , 9. \nMichael Janner, Karthik Narasimhan, and Regina Barzilay. 2018. Representation learning for grounded spatial reasoning.  Transactions of the As- sociation for Computational Linguistics , 6. \nSahar Kazemzadeh, Vicente Ordonez, Mark Matten, and Tamara L. Berg. 2014. Referitgame: Referring to objects in photographs of natural scenes. In  Pro- ceedings of the Conference on Empirical Methods in Natural Language Processing . \nJoohyun Kim and Raymond Mooney. 2012. Unsuper- vised PCFG induction for grounded language learn- ing with highly ambiguous supervision. In  Proceed- ings of the Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning . \nDiederik Kingma and Jimmy Ba. 2014. Adam: A method for stochastic optimization. In  Proceedings of the International Conference on Learning Repre- sentations . \nNikita Kitaev and Dan Klein. 2017. Where is misty? interpreting spatial descriptors by modeling regions in space. In  Proceedings of the Conference on Em- pirical Methods in Natural Language Processing . \nChen Kong, Dahua Lin, Mohit Bansal, Raquel Urta- sun, and Sanja Fidler. 2014. What are you talking about? text-to-image coreference. In  Proceedings of the IEEE Conference on Computer Vision and Pat- tern Recognition . \nJayant Krishnamurthy and T. Kollar. 2013. Jointly learning to parse and perceive: Connecting natural language to the physical world.  Transactions of the Association for Computational Linguistics , 1. \nYann LeCun, Léon Bottou, Yoshua Bengio, and Patrick Haffner. 1998. Gradient-based learning applied to document recognition.  Proceedings of the IEEE , 86. "}
{"page": 10, "image_path": "doc_images/D18-1287_10.jpg", "ocr_text": "Andrew L Maas, Awni Y Hannun, and Andrew Y Ng.\n2013. Rectifier nonlinearities improve neural net-\nwork acoustic models. In Proceedings of the inter-\nnational conference on machine learning.\n\nJames MacGlashan, Monica Babes-Vroman, Marie\ndesJardins, Michael L. Littman, Smaranda Muresan,\nS Bertel Squire, Stefanie Tellex, Dilip Arumugam,\nand Lei Yang. 2015. Grounding english commands\nto reward functions. In Robotics: Science and Sys-\ntems.\n\nMatthew MacMahon, Brian Stankiewics, and Ben-\njamin Kuipers. 2006. Walk the talk: Connecting\nlanguage, knowledge, action in route instructions.\nIn Proceedings of the National Conference on Ar-\ntificial Intelligence.\n\nJunhua Mao, Jonathan Huang, Alexander Toshev, Oana\nCamburu, Alan Yuille, and Kevin Murphy. 2016.\nGeneration and Comprehension of Unambiguous\nObject Descriptions. In Proceedings of IEEE Con-\nference on Computer Vision and Pattern Recogni-\ntion.\n\nCynthia Matuszek, Nicholas FitzGerald, Luke Zettle-\nmoyer, Liefeng Bo, and Dieter Fox. 2012a. A joint\nmodel of language and perception for grounded at-\ntribute learning. In Proceedings of the International\nConference on Machine Learning.\n\nCynthia Matuszek, Evan Herbst, Luke Zettlemoyer,\nand Dieter Fox. 2012b. Learning to parse natural\nlanguage commands to a robot control system. In\nProceedings of the International Symposium on Ex-\nperimental Robotics.\n\nHongyuan Mei, Mohit Bansal, and R. Matthew Walter.\n2016. What to talk about and how? selective gener-\nation using Istms with coarse-to-fine alignment. In\nProceedings of the Conference of the North Amer-\nican Chapter of the Association for Computational\nLinguistics: Human Language Technologies.\n\nDipendra Misra, John Langford, and Yoav Artzi. 2017.\nMapping instructions and visual observations to ac-\ntions with reinforcement learning. In Proceedings\nof the Conference on Empirical Methods in Natural\nLanguage Processing.\n\nDipendra K. Misra, Jaeyong Sung, Kevin Lee, and\nAshutosh Saxena. 2016. Tell me dave: Context-\nsensitive grounding of natural language to manip-\nulation instructions. The International Journal of\nRobotics Research, 35.\n\nKumar Dipendra Misra, Kejia Tao, Percy Liang, and\nAshutosh Saxena. 2015. Environment-driven lexi-\ncon induction for high-level instructions. In Pro-\nceedings of the Annual Meeting of the Association\nfor Computational Linguistics and the International\nJoint Conference on Natural Language Processing.\n\nVolodymyr Mnih, Koray Kavukcuoglu, David Silver,\nAlex Graves, Ioannis Antonoglou, Daan Wierstra,\nand Martin A. Riedmiller. 2013. Playing atari with\n\ndeep reinforcement learning. In Advances in Neural\nInformation Processing Systems.\n\nVinod Nair and Geoffrey E Hinton. 2010. Rectified lin-\near units improve restricted boltzmann machines. In\nProceedings of the international conference on ma-\nchine learning.\n\nAndrew Y. Ng, Daishi Harada, and Stuart J. Russell.\n1999. Policy invariance under reward transforma-\ntions: Theory and application to reward shaping. In\nProceedings of the International Conference on Ma-\nchine Learning.\n\nJunhyuk Oh, Satinder P. Singh, Honglak Lee, and\nPushmeet Kohli. 2017. Zero-shot task generaliza-\ntion with multi-task deep reinforcement learning. In\nProceedings of the international conference on ma-\nchine learning.\n\nJan Peters and Stefan Schaal. 2008. Reinforcement\nlearning of motor skills with policy gradients. Neu-\nral networks, 21.\n\nBenjamin Recht, Christopher Re, Stephen Wright, and\nFeng Niu. 2011. Hogwild: A lock-free approach\nto parallelizing stochastic gradient descent. In Ad-\nvances in Neural Information Processing Systems.\n\nOlaf Ronneberger, Philipp Fischer, and Thomas Brox.\n2015. U-net: Convolutional networks for biomed-\nical image segmentation. In International Confer-\nence on Medical image computing and computer-\nassisted intervention.\n\nJohn Schulman, Philipp Moritz, Sergey Levine,\nMichael I. Jordan, and Pieter Abbeel. 2015. High-\ndimensional continuous control using generalized\nadvantage estimation. CoRR, abs/1506.02438.\n\nNitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,\nIlya Sutskever, and Ruslan Salakhutdinov. 2014.\nDropout: A simple way to prevent neural networks\nfrom overfitting. The Journal of Machine Learning\nResearch, 15.\n\nAlane Suhr and Yoav Artzi. 2018. Situated mapping\nof sequential instructions to actions with single-step\nreward observation. In Proceedings of the Annual\nMeeting of the Association for Computational Lin-\nguistics.\n\nRichard S. Sutton, Doina Precup, and Satinder P. Singh.\n1998. Intra-option learning about temporally ab-\nstract actions. In Proceedings of the international\nconference on machine learning.\n\nDmitry Ulyanov, Andrea Vedaldi, and Victor S.\nLempitsky. 2016. Instance normalization: The\nmissing ingredient for fast stylization. CoRR,\nabs/1607.08022.\n\nRonald J. Williams. 1992. Simple statistical gradient-\nfollowing algorithms for connectionist reinforce-\nment learning. Machine Learning, 8.\n\n2677\n", "vlm_text": "2013. Rectiﬁer nonlinearities improve neural net- work acoustic models. In  Proceedings of the inter- national conference on machine learning . James MacGlashan, Monica Babes-Vroman, Marie desJardins, Michael L. Littman, Smaranda Muresan, S Bertel Squire, Stefanie Tellex, Dilip Arumugam, and Lei Yang. 2015. Grounding english commands to reward functions. In  Robotics: Science and Sys- tems . Matthew MacMahon, Brian Stankiewics, and Ben- jamin Kuipers. 2006. Walk the talk: Connecting language, knowledge, action in route instructions. In  Proceedings of the National Conference on Ar- tiﬁcial Intelligence . Junhua Mao, Jonathan Huang, Alexander Toshev, Oana Camburu, Alan Yuille, and Kevin Murphy. 2016. Generation and Comprehension of Unambiguous Object Descriptions. In  Proceedings of IEEE Con- ference on Computer Vision and Pattern Recogni- tion . Cynthia Matuszek, Nicholas FitzGerald, Luke Zettle- moyer, Liefeng Bo, and Dieter Fox. 2012a. A joint model of language and perception for grounded at- tribute learning. In  Proceedings of the International Conference on Machine Learning . Cynthia Matuszek, Evan Herbst, Luke Zettlemoyer, and Dieter Fox. 2012b. Learning to parse natural language commands to a robot control system. In Proceedings of the International Symposium on Ex- perimental Robotics . Hongyuan Mei, Mohit Bansal, and R. Matthew Walter. 2016. What to talk about and how? selective gener- ation using lstms with coarse-to-ﬁne alignment. In Proceedings of the Conference of the North Amer- ican Chapter of the Association for Computational Linguistics: Human Language Technologies . Dipendra Misra, John Langford, and Yoav Artzi. 2017. Mapping instructions and visual observations to ac- tions with reinforcement learning. In  Proceedings of the Conference on Empirical Methods in Natural Language Processing . Dipendra K. Misra, Jaeyong Sung, Kevin Lee, and Ashutosh Saxena. 2016. Tell me dave: Context- sensitive grounding of natural language to manip- ulation instructions. The International Journal of Robotics Research , 35. Kumar Dipendra Misra, Kejia Tao, Percy Liang, and Ashutosh Saxena. 2015. Environment-driven lexi- con induction for high-level instructions. In  Pro- ceedings of the Annual Meeting of the Association for Computational Linguistics and the International Joint Conference on Natural Language Processing . Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, and Martin A. Riedmiller. 2013. Playing atari with \ndeep reinforcement learning. In  Advances in Neural \nInformation Processing Systems . Vinod Nair and Geoffrey E Hinton. 2010. Rectiﬁed lin- ear units improve restricted boltzmann machines. In Proceedings of the international conference on ma- chine learning . Andrew Y. Ng, Daishi Harada, and Stuart J. Russell. 1999. Policy invariance under reward transforma- tions: Theory and application to reward shaping. In Proceedings of the International Conference on Ma- chine Learning . Junhyuk Oh, Satinder P. Singh, Honglak Lee, and Pushmeet Kohli. 2017. Zero-shot task generaliza- tion with multi-task deep reinforcement learning. In Proceedings of the international conference on ma- chine learning . Jan Peters and Stefan Schaal. 2008. Reinforcement learning of motor skills with policy gradients.  Neu- ral networks , 21. Benjamin Recht, Christopher Re, Stephen Wright, and Feng Niu. 2011. Hogwild: A lock-free approach to parallelizing stochastic gradient descent. In  Ad- vances in Neural Information Processing Systems . Olaf Ronneberger, Philipp Fischer, and Thomas Brox. 2015. U-net: Convolutional networks for biomed- ical image segmentation. In  International Confer- ence on Medical image computing and computer- assisted intervention . John Schulman, Philipp Moritz, Sergey Levine, Michael I. Jordan, and Pieter Abbeel. 2015. High- dimensional continuous control using generalized advantage estimation.  CoRR , abs/1506.02438. Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. 2014. Dropout: A simple way to prevent neural networks from overﬁtting.  The Journal of Machine Learning Research , 15. Alane Suhr and Yoav Artzi. 2018. Situated mapping of sequential instructions to actions with single-step reward observation. In  Proceedings of the Annual Meeting of the Association for Computational Lin- guistics . Richard S. Sutton, Doina Precup, and Satinder P. Singh. 1998. Intra-option learning about temporally ab- stract actions. In  Proceedings of the international conference on machine learning . Dmitry Ulyanov, Andrea Vedaldi, and Victor S. Lempitsky. 2016. Instance normalization: The missing ingredient for fast stylization. CoRR , abs/1607.08022. Ronald J. Williams. 1992. Simple statistical gradient- following algorithms for connectionist reinforce- ment learning.  Machine Learning , 8. "}
{"page": 11, "image_path": "doc_images/D18-1287_11.jpg", "ocr_text": "Wenhan Xiong, Xiaoxiao Guo, Mo Yu, Shiyu Chang,\nBowen Zhou, and William Yang Wang. 2018.\nScheduled policy optimization for natural language\ncommunication with intelligent agents. In Proceed-\nings of the International Joint Conferences on Arti-\nficial Intelligence.\n\nClaudia Yan, Dipendra Kumar Misra, Andrew Ben-\nnett, Aaron Walsman, Yonatan Bisk, and Yoav Artzi.\n2018. Chalet: Cornell house agent learning environ-\nment. CoRR, abs/1801.07357.\n\nLicheng Yu, Patrick Poirson, Shan Yang, Alexander C.\nBerg, and Tamara L. Berg. 2016. Modeling context\nin referring expressions. In Proceedings of the Eu-\nropean Conference on Computer Vision.\n\n2678\n", "vlm_text": "Wenhan Xiong, Xiaoxiao Guo, Mo Yu, Shiyu Chang, Bowen Zhou, and William Yang Wang. 2018. Scheduled policy optimization for natural language communication with intelligent agents. In  Proceed- ings of the International Joint Conferences on Arti- ﬁcial Intelligence . Claudia Yan, Dipendra Kumar Misra, Andrew Ben- nett, Aaron Walsman, Yonatan Bisk, and Yoav Artzi. 2018. Chalet: Cornell house agent learning environ- ment.  CoRR , abs/1801.07357. Licheng Yu, Patrick Poirson, Shan Yang, Alexander C. Berg, and Tamara L. Berg. 2016. Modeling context in referring expressions. In  Proceedings of the Eu- ropean Conference on Computer Vision . "}
