{"layout": 0, "type": "text", "text": "CodeBERT: A Pre-Trained Model for Programming and Natural Languages ", "text_level": 1, "page_idx": 0, "bbox": [103, 69, 494, 101], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 1, "type": "text", "text": "Zhangyin  $\\mathbf{Feng}^{1;}$  , Daya  $\\mathbf{{G u o}^{2}}$  , Duyu Tang 3 , Nan Duan 3 , Xiaocheng Feng 1 Ming   $\\mathbf{G o n g^{4}}$  , Linjun Shou 4 , Bing  $\\mathbf{Q}\\mathbf{in}^{1}$  , Ting   $\\mathbf{L}\\mathbf{i}\\mathbf{u}^{1}$  , Daxin Jiang 4 , Ming Zhou 3 ", "page_idx": 0, "bbox": [105.12896728515625, 112.91802978515625, 494.903076171875, 142.41973876953125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 2, "type": "text", "text": "1  Research Center for Social Computing and Information Retrieval, Harbin Institute of Technology, China 2  The School of Data and Computer Science, Sun Yat-sen University, China 3  Microsoft Research Asia, Beijing, China ", "page_idx": 0, "bbox": [46.8199462890625, 136.90542602539062, 553.7183837890625, 183.54544067382812], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 3, "type": "text", "text": "{ zyfeng,xcfeng,qinb,tliu } @ir.hit.edu.cn guody5@mail2.sysu.edu.cn dutang,nanduan,migon,lisho,djiang,mingzhou @microsoft.com ", "page_idx": 0, "bbox": [99.41891479492188, 198.38539123535156, 507.0906677246094, 238.81044006347656], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 4, "type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0, "bbox": [159, 262, 204, 274], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 5, "type": "text", "text": "We present CodeBERT, a  bimodal  pre-trained model for programming language (PL) and natural language (NL). CodeBERT learns general-purpose representations that support downstream NL-PL applications such as nat- ural language code search, code documen- tation generation, etc. We develop Code- BERT with Transformer-based neural architec- ture, and train it with a hybrid objective func- tion that incorporates the pre-training task of replaced token detection, which is to detect plausible alternatives sampled from generators. This enables us to utilize both “ bimodal ” data of NL-PL pairs and “ unimodal ” data, where the former provides input tokens for model training while the latter helps to learn bet- ter generators. We evaluate CodeBERT on two NL-PL applications by ﬁne-tuning model parameters. Results show that CodeBERT achieves state-of-the-art performance on both natural language code search and code docu- mentation generation. Furthermore, to inves- tigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and evaluate in a zero-shot setting where parameters of pre-trained models are ﬁxed. Results show that CodeBERT performs better than previous pre-trained models on NL- PL probing. ", "page_idx": 0, "bbox": [88, 288.81158447265625, 274, 635.561279296875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 6, "type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0, "bbox": [71, 649, 155, 663], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 7, "type": "text", "text": "Large pre-trained models such as ELMo ( Peters et al. ,  2018 ), GPT ( Radford et al. ,  2018 ), BERT ( Devlin et al. ,  2018 ), XLNet ( Yang et al. ,  2019 ) ", "page_idx": 0, "bbox": [71, 673.56201171875, 291, 713.8064575195312], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 8, "type": "text", "text": "and RoBERTa ( Liu et al. ,  2019 ) have dramati- cally improved the state-of-the-art on a variety of natural language processing (NLP) tasks. These pre-trained models learn effective contextual repre- sentations from massive unlabeled text optimized by self-supervised objectives, such as masked language modeling, which predicts the original masked word from an artiﬁcially masked input sequence. The success of pre-trained models in NLP also drives a surge of multi-modal pre-trained models, such as ViLBERT ( Lu et al. ,  2019 ) for language-image and VideoBERT ( Sun et al. ,  2019 ) for language-video, which are learned from  bi- modal  data such as language-image pairs with  bi- modal  self-supervised objectives. ", "page_idx": 0, "bbox": [307, 262.11297607421875, 527, 464.94647216796875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 9, "type": "text", "text": "In this work, we present CodeBERT, a  bimodal pre-trained model for natural language (NL) and programming language (PL) like Python, Java, JavaScript, etc. CodeBERT captures the seman- tic connection between natural language and pro- gramming language, and produces general-purpose representations that can broadly support NL-PL understanding tasks (e.g. natural language code search) and generation tasks (e.g. code documen- tation generation). It is  developed  with the multi- layer Transformer ( Vaswani et al. ,  2017 ), which is adopted in a majority of large pre-trained models. In order to make use of both  bimodal  instances of NL-PL pairs and large amount of available  uni- modal  codes, we train CodeBERT with a hybrid objective function, including standard masked lan- guage modeling ( Devlin et al. ,  2018 ) and replaced token detection ( Clark et al. ,  2020 ), where  uni- modal  codes help to learn better generators for producing better alternative tokens for the latter objective. ", "page_idx": 0, "bbox": [307, 466.85198974609375, 527, 750.9814453125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 10, "type": "text", "text": "We train CodeBERT from Github code reposito- ries in 6 programming languages, where  bimodal datapoints are codes that pair with function-level natural language documentations ( Husain et al. , 2019 ). Training is conducted in a setting similar to that of multilingual BERT ( Pires et al. ,  2019 ), in which case one pre-trained model is learned for 6 programming languages with no explicit mark- ers used to denote the input programming lan- guage. We evaluate CodeBERT on two down- stream NL-PL tasks, including natural language code search and code documentation generation. Results show that ﬁne-tuning the parameters of CodeBERT achieves state-of-the-art performance on both tasks. To further investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and test CodeBERT in a zero-shot scenario, i.e. without ﬁne-tuning the parameters of CodeBERT. We ﬁnd that CodeBERT consistently outperforms RoBERTa, a purely natu- ral language-based pre-trained model. The contri- butions of this work are as follows: ", "page_idx": 0, "bbox": [318, 752.885986328125, 527, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 11, "type": "text", "text": "", "page_idx": 1, "bbox": [72, 63.68701934814453, 292, 347.81646728515625], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 12, "type": "text", "text": "•  CodeBERT is the ﬁrst large NL-PL pre- trained model for multiple programming lan- guages. •  Empirical results show that CodeBERT is ef- fective in both code search and code-to-text generation tasks. •  We further created a dataset which is the ﬁrst one to investigate the probing ability of the code-based pre-trained models. ", "page_idx": 1, "bbox": [85, 357.9859924316406, 292, 499.05548095703125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 13, "type": "text", "text": "2 Background ", "text_level": 1, "page_idx": 1, "bbox": [71, 510, 153, 523], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 14, "type": "text", "text": "2.1 Pre-Trained Models in NLP ", "text_level": 1, "page_idx": 1, "bbox": [71, 532, 227, 544], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 15, "type": "text", "text": "Large pre-trained models ( Peters et al. ,  2018 ;  Rad- ford et al. ,  2018 ;  Devlin et al. ,  2018 ;  Yang et al. , 2019 ;  Liu et al. ,  2019 ;  Raffel et al. ,  2019 ) have brought dramatic empirical improvements on al- most every NLP task in the past few years. Suc- cessful approaches train deep neural networks on large-scale plain texts with self-supervised learning objectives. One of the most representative neural architectures is the Transformer ( Vaswani et al. , 2017 ), which is also the one used in this work. It contains multiple self-attention layers, and can be conventionally learned with gradient decent in an end-to-end manner as every component is differen- tiable. The terminology “self-supervised” means that supervisions used for pre-training are auto- matically collected from raw data without manual annotation. Dominant learning objectives are lan- guage modeling and its variations. For example, in  GPT  ( Radford et al. ,  2018 ), the learning objec- tive is language modeling, namely predicting the next word    $w_{k}$   given the preceding context words  $\\{w_{1},w_{2},...,w_{k-1}\\}$  . As the ultimate goal of pre- training is not to train a good language model, it is desirable to consider both preceding and following contexts to learn better general-purpose contextual representations. This leads us to the masked lan- guage modeling objective used in BERT ( Devlin et al. ,  2018 ), which learns to predict the masked words of a randomly masked word sequence given surrounding contexts. Masked language modeling is also used as one of the two learning objectives for training CodeBERT. ", "page_idx": 1, "bbox": [72, 549.6480102539062, 292, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 16, "type": "text", "text": "", "page_idx": 1, "bbox": [306, 63.68701934814453, 527, 280.0704650878906], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 17, "type": "text", "text": "2.2 Multi-Modal Pre-Trained Models ", "text_level": 1, "page_idx": 1, "bbox": [307, 297, 489, 308], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 18, "type": "text", "text": "The remarkable success of the pre-trained model in NLP has driven the development of multi-modal pre-trained model that learns implicit alignment between inputs of different modalities. These mod- els are typically learned from  bimodal  data, such as pairs of language-image or pairs of language- video. For example, ViLBERT ( Lu et al. ,  2019 ) learns from image caption data, where the model learns by reconstructing categories of masked im- age region or masked words given the observed inputs, and meanwhile predicting whether the cap- tion describes the image content or not. Simi- larly, VideoBERT ( Sun et al. ,  2019 ) learns from language-video data and is trained by video and text masked token prediction. Our work belongs to this line of research as we regard NL and PL as different modalities. Our method differs from previous works in that the fuels for model train- ing include not only  bimodal  data of NL-PL pairs, but larger amounts of  unimodal  data such as codes without paired documentations. ", "page_idx": 1, "bbox": [306, 317.3699951171875, 527, 601.4984130859375], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 19, "type": "text", "text": "A concurrent work ( Kanade et al. ,  2019 ) uses masked language modeling and next sentence pre- diction as the objective to train a BERT model on Python source codes, where a sentence is a log- ical code line as deﬁned by the Python standard. In terms of the pre-training process, CodeBERT differs from their work in that (1) CodeBERT is trained in a cross-modal style and leverages both bimodal NL-PL data and unimodal PL/NL data, (2) CodeBERT is pre-trained over six programming languages, and (3) CodeBERT is trained with a new learning objective based on replaced token ", "page_idx": 1, "bbox": [306, 603.8450317382812, 527, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 20, "type": "text", "text": "3 CodeBERT ", "text_level": 1, "page_idx": 2, "bbox": [71, 87, 149, 102], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 21, "type": "text", "text": "We describe the details about CodeBERT in this section, including the model architecture, the input and output representations, the objectives and data used for training CodeBERT, and how to ﬁne-tune CodeBERT when it is applied to downstream tasks. ", "page_idx": 2, "bbox": [71, 110.82801055908203, 292, 178.17050170898438], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 22, "type": "text", "text": "3.1 Model Architecture ", "text_level": 1, "page_idx": 2, "bbox": [71, 189, 188, 202], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 23, "type": "text", "text": "We follow BERT ( Devlin et al. ,  2018 ) and RoBERTa ( Liu et al. ,  2019 ), and use multi-layer bidirectional Transformer ( Vaswani et al. ,  2017 ) as the model architecture of CodeBERT. We will not review the ubiquitous Transformer architecture in detail. We develop CodeBERT by using exactly the same model architecture as RoBERTa-base. The total number of model parameters is 125M. ", "page_idx": 2, "bbox": [71, 207.14503479003906, 292, 315.1344909667969], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 24, "type": "text", "text": "3.2 Input/Output Representations ", "text_level": 1, "page_idx": 2, "bbox": [71, 326, 238, 339], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 25, "type": "text", "text": "In the pre-training phase, we set the input as the concatenation of two segments with a special sepa- rator token, namely    $[C L S],w_{1},w_{2},..w_{n},[S E P].$  ,  $c_{1},c_{2},...,c_{m},[E O S]$  . One segment is natural lan- guage text, and another is code from a certain pro- gramming language.    $[C L S]$   is a special token in front of the two segments, whose ﬁnal hidden repre- sentation is considered as the aggregated sequence representation for classiﬁcation or ranking. Follow- ing the standard way of processing text in Trans- former, we regard a natural language text as a se- quence of words, and split it as WordPiece ( Wu et al. ,  2016 ). We regard a piece of code as a se- quence of tokens. ", "page_idx": 2, "bbox": [71, 344.1090087890625, 292, 533.3934326171875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 26, "type": "text", "text": "The output of CodeBERT includes (1) contextual vector representation of each token, for both natural language and code, and (2) the representation of  $[C L S]$  , which works as the aggregated sequence representation. ", "page_idx": 2, "bbox": [71, 534.2119750976562, 292, 601.554443359375], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 27, "type": "text", "text": "3.3 Pre-Training Data ", "text_level": 1, "page_idx": 2, "bbox": [71, 612, 183, 626], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 28, "type": "text", "text": "We train CodeBERT with both  bimodal  data, which refers to parallel data of natural language-code pairs, and  unimodal  data, which stands for codes without paired natural language texts and natural language without paired codes. ", "page_idx": 2, "bbox": [71, 630.5289916992188, 292, 697.8704223632812], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 29, "type": "text", "text": "We use datapoints from Github repositories, where each  bimodal  datapoint is an individual function with paired documentation, and each  uni- modal  code is a function without paired documen- tation. Speciﬁcally, we use a recent large dataset ", "page_idx": 2, "bbox": [71, 698.6890258789062, 292, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 30, "type": "table", "page_idx": 2, "img_path": "layout_images/2020.findings-emnlp.139_0.jpg", "table_footnote": "Table 1: Statistics of the dataset used for training Code- BERT. ", "bbox": [306, 61, 527, 185], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "TRAINING DATA — bimodal DATA —_ unimodal CODES\n\nGo 319,256 726,768\nJAVA 500,754 1,569,889\nJAVASCRIPT 143,252 1,857,835\nPHP 662,907 977,821\nPYTHON 458,219 1,156,085\nRUBY 52,905 164,048\n\nALL 2,137,293 6,452,446\n", "vlm_text": "The table presents information about training data split into two categories: bimodal data and unimodal codes, for various programming languages including Go, Java, JavaScript, PHP, Python, and Ruby. \n\n- For Go, the table lists 319,256 bimodal data points and 726,768 unimodal codes.\n- For Java, there are 500,754 bimodal data points and 1,569,889 unimodal codes.\n- For JavaScript, 143,252 bimodal data points and 1,857,835 unimodal codes are shown.\n- For PHP, the table lists 662,907 bimodal data points and 977,821 unimodal codes.\n- For Python, there are 458,219 bimodal data points and 1,156,085 unimodal codes.\n- For Ruby, the numbers are 52,905 bimodal data points and 164,048 unimodal codes.\n\nIn total (labeled as All), there are 2,137,293 bimodal data points and 6,452,446 unimodal codes across all these languages."}
{"layout": 31, "type": "text", "text": "provided by  Husain et al.  ( 2019 ), which includes 2.1M  bimodal  datapoints and 6.4M  unimodal  codes across six programming languages (Python, Java, JavaScript, PHP, Ruby, and Go). Data statistics is shown in Table  1 . ", "page_idx": 2, "bbox": [306, 206.70899963378906, 527, 274.0514831542969], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 32, "type": "text", "text": "The data comes from publicly available open- source non-fork GitHub repositories and are ﬁl- tered with a set of constraints and rules. For ex- ample, (1) each project should be used by at least one other project, (2) each documentation is trun- cated to the ﬁrst paragraph, (3) documentations shorter than three tokens are removed, (4) func- tions shorter than three lines are removed, and (5) function names with substring “ test ” are removed. An example of the data is given in Figure    $1\\,\\,{^3}$  . ", "page_idx": 2, "bbox": [306, 274.45501708984375, 527, 409.5434875488281], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 33, "type": "image", "page_idx": 2, "img_path": "layout_images/2020.findings-emnlp.139_1.jpg", "img_caption": "Figure 1: An example of the NL-PL pair, where NL is the ﬁrst paragraph (ﬁlled in red) from the documenta- tion (dashed line in black) of a function. ", "bbox": [306, 419, 528, 583], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "def _parse_memory(s\n\n>>> _parse_memory(\"256m\")\n256\n\n>>> _parse_memory(\"2g\")\n2048\n\nunits = {‘g': 1024, ‘m'\nif s[-1].lower() not in unit:\nraise Valuefrror(\"invalid format: \" + s)\n\nreturn int(float(s[:-1]) * units[s[-1].lower()])\n\n", "vlm_text": "The image shows a snippet of Python code inside a documentation block for a function named `_parse_memory`. The code is intended to parse a memory string in the format supported by Java (e.g., \"1g\", \"200m\") and return its value in mebibytes (MiB). The documentation paragraph is highlighted with a red-filled box, which says: \"Parse a memory string in the format supported by Java (e.g., 1g, 200m) and return the value in MiB.\"\n\nThe function converts input strings like \"256m\" and \"2g\" into their equivalent memory values in MiB, returning 256 and 2048, respectively, as shown in the example usage code below the documentation paragraph. The implementation uses a dictionary `units` to map suffixes ('g', 'm', 't', 'k') to their respective conversion factors with 'g' being 1024. It checks if the last character of the input (`s[-1]`) is in the dictionary keys, raises a `ValueError` for invalid formats, and calculates the memory in MiB using the conversion factor.\n\nThe overall layout of this image illustrates how documentation (natural language, NL) is paired with the corresponding code implementation (programming language, PL) for clarity."}
{"layout": 34, "type": "text", "text": "3.4 Pre-Training CodeBERT ", "text_level": 1, "page_idx": 2, "bbox": [306, 606, 448, 619], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 35, "type": "text", "text": "We describe the two objectives used for training CodeBERT here. The ﬁrst objective is masked language modeling (MLM), which has proven ef- fective in literature ( Devlin et al. ,  2018 ;  Liu et al. , ", "page_idx": 2, "bbox": [306, 623.0059814453125, 527, 676.7994384765625], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 36, "type": "image", "page_idx": 3, "img_path": "layout_images/2020.findings-emnlp.139_2.jpg", "img_caption": "Figure 2: An illustration about the replaced token detection objective. Both NL and code generators are language models, which generate plausible tokens for masked positions based on surrounding contexts. NL-Code discrimi- nator is the targeted pre-trained model, which is trained via detecting plausible alternatives tokens sampled from NL and PL generators. NL-Code discriminator is used for producing general-purpose representations in the ﬁne- tuning step. Both NL and code generators are thrown out in the ﬁne-tuning step. ", "bbox": [70, 62, 527, 316], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "w, ——> [MASK], ——>\nWw, ———* W2\nWw3 ———> ws\nW4 ————> Wa\n\nWs ——> [MASK] ——>\n\nc. ——\nCc. ——> [MASK], ——>\nC3 > C3\n4. —— &\ncs ¢s\n\n6 ——> [MASK], ——>\n\nNL Generator\n\nCode Generator\n\nsample\n\nNL-Code\nDiscriminator\n\nreplaced\noriginal\noriginal\noriginal\n\noriginal\n\noriginal\nreplaced\noriginal\noriginal\noriginal\n\nreplaced\n", "vlm_text": "The image depicts a schematic illustrating the replaced token detection objective, highlighting the roles of natural language (NL) and code (PL) generators, as well as a discriminator. The process is as follows:\n\n1. **Masked Token Inputs:** \n   - Natural language (NL) inputs (`w_1, w_2, ..., w_5`) and code inputs (`c_1, c_2, ..., c_6`) have certain tokens masked (`[MASK]_w`, `[MASK]_c`).\n\n2. **Token Generation:**\n   - The NL Generator tries to fill in the masked tokens in the natural language inputs. For example, `[MASK]_w` gets replaced with tokens like `w_51` and another `[MASK]_w` might be replaced with `w_5`.\n   - Similarly, the Code Generator fills masked positions within the code sequence, replacing `[MASK]_c` with tokens like `c_29` or `c_162`.\n\n3. **Discriminator:**\n   - Both the generated sequences from the NL and code generators are passed to the NL-Code Discriminator.\n   - This discriminator is trained to identify whether the tokens at the masked positions in both NL and code sequences are \"replaced\" or \"original.\"\n\n4. **Output Labels:**\n   - The discriminator outputs labels indicating whether a token at the masked position is originally from the sequence or replaced. This is shown on the right side of the image with labels such as \"replaced\" or \"original.\"\n\n5. **Training and Fine-Tuning:** \n   - The focus is on training the NL-Code discriminator to produce general-purpose representations by detecting tokens from the NL and code generators.\n   - In the fine-tuning step, the NL and code generators are discarded.\n\nThis figure emphasizes the model's training process to detect modifications within sequences, enhancing the model's ability to create robust representations."}
{"layout": 37, "type": "text", "text": "2019 ;  Sun et al. ,  2019 ). We apply masked language modeling on  bimodal  data of NL-PL pairs. The sec- ond objective is replaced token detection (RTD), which further uses a large amount of  unimodal  data, such as codes without paired natural language texts. Detailed hyper-parameters for model pre-training are given in Appendix B.1. ", "page_idx": 3, "bbox": [70, 337.7099914550781, 291, 432.1504821777344], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 38, "type": "text", "text": "Objective #1: Masked Language Modeling\n\n (MLM) Given a datapoint of NL-PL pair   $({\\pmb x}=\n\n$   $\\{\\pmb{w},\\,\\pmb{c}\\})$   as nput, where    $\\mathbfit{w}$   is a sequence of  $\\mathrm{NL}$  words and  c  is a sequence of PL tokens, we ﬁrst select a random set of positions for both  $\\mathrm{NL}$   and PL to mask out (i.e.    $_m w$    and  $_m\\!^{c}$  , respectively), and then replace the selected positions with a special  $[M A S K]$   token. Following  Devlin et al.  ( 2018 ),  $15\\%$   of the tokens from    $_{_{\\pmb{x}}}$   are masked out. ", "page_idx": 3, "bbox": [70, 439.3672790527344, 291, 561.2994384765625], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 39, "type": "equation", "text": "\n$$\n\\begin{array}{r}{m_{i}^{w}\\sim\\mathrm{unif}\\{1,|w|\\}\\;\\mathrm{for}\\;i=1\\;\\mathrm{to}\\;|w|\\;\\;\\;\\;\\;\\;\\;\\;}\\\\ {m_{i}^{c}\\sim\\mathrm{unif}\\{1,|c|\\}\\;\\mathrm{for}\\;i=1\\;\\mathrm{to}\\;|c|\\;\\;\\;\\;\\;\\;\\;}\\\\ {{w}^{\\mathrm{smoke}}=\\mathrm{REPLACE}(w,m^{w},[M A S K])\\;\\;}\\\\ {c^{\\mathrm{smoke}}=\\mathrm{REPLACE}(c,m^{c},[M A S K])\\;\\;\\;\\;\\;\\;\\;}\\\\ {{x}=w+c\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;}\\end{array}\n$$\n ", "text_format": "latex", "page_idx": 3, "bbox": [79, 568, 269, 655], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 40, "type": "text", "text": "The MLM objective is to predict the original to- kens which are masked out, formulated as follows, where    $p^{D_{1}}$    is the discriminator which predicts a token from a large vocabulary. ", "page_idx": 3, "bbox": [70, 664.3079833984375, 291, 718.1014404296875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 41, "type": "equation", "text": "\n$$\n\\mathcal{L}_{\\mathrm{MLM}}(\\theta)\\!=\\!\\sum_{i\\in m^{w}\\cup m^{c}}\\!-\\!\\log p^{D_{1}}(x_{i}|\\pmb{w}^{\\mathrm{smoke}},\\!c^{\\mathrm{mascade}})\n$$\n ", "text_format": "latex", "page_idx": 3, "bbox": [70, 725, 290, 755], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 42, "type": "text", "text": "Objective #2: Replaced Token Detection (RTD) In the MLM objective, only  bimodal  data (i.e. data- points of NL-PL pairs) is used for training. Here we present the objective of replaced token detection. The RTD objective ( Clark et al. ,  2020 ) is origi- nally developed for efﬁciently learning pre-trained model for natural language. We adapt it in our sce- nario, with the advantage of using both  bimodal and  unimodal  data for training. Speciﬁcally, there are two data generators here, an  $\\mathrm{NL}$   generator    $\\boldsymbol{p}^{G_{w}}$  and a PL generator    $p^{G_{c}}$  , both for generating plau- sible alternatives for the set of randomly masked positions. ", "page_idx": 3, "bbox": [307, 337.3172912597656, 527, 513.4454345703125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 43, "type": "equation", "text": "\n$$\n\\begin{array}{r}{\\hat{w}_{i}\\sim p^{G_{w}}(w_{i}|\\pmb{w}^{\\mathrm{unshock}})\\mathrm{~for~}i\\in\\pmb{m}^{w}}\\\\ {\\hat{c}_{i}\\sim p^{G_{c}}(c_{i}|\\pmb{c}^{\\mathrm{unshock}})\\mathrm{~for~}i\\in\\pmb{m}^{c}}\\end{array}\n$$\n ", "text_format": "latex", "page_idx": 3, "bbox": [336, 520, 496, 556], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 44, "type": "equation", "text": "\n$$\n\\begin{array}{r l}&{\\pmb{w}^{\\mathrm{corrupt}}=\\mathrm{REPLACE}(\\pmb{w},\\pmb{m}^{\\pmb{w}},\\hat{\\pmb{w}})}\\\\ &{\\pmb{c}^{\\mathrm{corrupt}}=\\mathrm{REPLACE}(\\pmb{c},\\pmb{m}^{c},\\hat{\\pmb{c}})}\\\\ &{\\pmb{x}^{\\mathrm{corrupt}}=\\pmb{w}^{\\mathrm{corrupt}}+\\pmb{c}^{\\mathrm{corrupt}}}\\end{array}\n$$\n ", "text_format": "latex", "page_idx": 3, "bbox": [339, 572, 494, 622], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 45, "type": "text", "text": "The discriminator is trained to determine whether a word is the original one or not, which is a binary classiﬁcation problem. It is worth noting that the RTD objective is applied to every position in the input, and it differs from GAN (generative adver- sarial network) in that if a generator happens to produce the correct token, the label of that token is “real” instead of “fake” ( Clark et al. ,  2020 ). The loss function of RTD with regard to the discrimina- tor parameterized by  $\\theta$   is given below, where    $\\delta(i)$   is an indicator function and  $p^{D_{2}}$    is the discriminator that predicts the probability of the  $i$  -th word being original. ", "page_idx": 3, "bbox": [307, 630.9429931640625, 527, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 46, "type": "text", "text": "", "page_idx": 4, "bbox": [71, 60.83502960205078, 292, 103.93148803710938], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 47, "type": "equation", "text": "\n$$\n\\begin{array}{r l}&{\\mathcal{L}_{\\mathrm{RTD}}(\\theta)=\\displaystyle\\sum_{i=1}^{|w|+|c|}\\bigg(\\delta(i){\\log p^{D_{2}}}({\\mathbf{x}}^{\\mathrm{corrupt}},i)+}\\\\ &{\\qquad\\qquad\\Big(1-\\delta(i)\\Big)\\Big(1-\\log p^{D_{2}}({\\mathbf{x}}^{\\mathrm{corrupt}},i)\\Big)\\bigg)}\\end{array}\n$$\n ", "text_format": "latex", "page_idx": 4, "bbox": [69, 112, 294, 181], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 48, "type": "equation", "text": "\n$$\n\\delta(i)={\\left\\{\\begin{array}{l l}{1,}&{{\\mathrm{if~}}x_{i}^{\\mathrm{corrupt}}=x_{i}.}\\\\ {0,}&{{\\mathrm{otherwise}}.}\\end{array}\\right.}\n$$\n ", "text_format": "latex", "page_idx": 4, "bbox": [115, 205, 245, 242], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 49, "type": "text", "text": "There are many different ways to implement the generators. In this work, we implement two ef- ﬁcient  $\\mathbf{n}$  -gram language models ( Jurafsky ,  2000 ) with bidirectional contexts, one for NL and one for PL, and learn them from corresponding uni- model datapoints, respectively. The approach is easily generalized to learn  bimodal  generators or use more complicated generators like Transformer- based neural architecture learned in a joint manner. We leave these to future work. The PL training data is the  unimodal  codes as shown in Table  1 , and the NL training data comes from the documentations from  bimodal  data. One could easily extend these two training datasets to larger amount. The ﬁnal loss function are given below. ", "page_idx": 4, "bbox": [71, 245.8300323486328, 292, 448.6634826660156], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 50, "type": "equation", "text": "\n$$\n\\operatorname*{min}_{\\theta}\\mathcal{L}_{\\mathrm{MLM}}(\\theta)+\\mathcal{L}_{\\mathrm{RTD}}(\\theta)\n$$\n ", "text_format": "latex", "page_idx": 4, "bbox": [122, 458, 238, 478], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 51, "type": "text", "text": "3.5 Fine-Tuning CodeBERT ", "text_level": 1, "page_idx": 4, "bbox": [71, 488, 210, 500], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 52, "type": "text", "text": "We have different settings to use CodeBERT in downstream NL-PL tasks. For example, in natural language code search, we feed the input as the same way as the pre-training phase and use the representation of    $[C L S]$   to measure the semantic relevance between code and natural language query, while in code-to-text generation, we use an encoder- decoder framework and initialize the encoder of a generative model with CodeBERT. Details are given in the experiment section. ", "page_idx": 4, "bbox": [71, 505.03302001953125, 292, 640.1204223632812], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 53, "type": "text", "text": "4 Experiment ", "text_level": 1, "page_idx": 4, "bbox": [71, 651, 151, 663], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 54, "type": "text", "text": "We present empirical results in this section to verify the effectiveness of CodeBERT. We ﬁrst describe the use of CodeBERT in natural language code search ( § 4.1 ), in a way that model parameters of CodeBERT are ﬁne-tuned. After that, we present the NL-PL probing task ( § 4.2 ), and evaluate Code- BERT in a zero-shot setting where the parameters of CodeBERT are ﬁxed. Finally, we evaluate Code- BERT on a generation problem, i.e. code documen- tation generation ( § 4.3 ), and further evaluate on a programming language which is never seen in the training phase (§ 4.4 ). ", "page_idx": 4, "bbox": [71, 671.5910034179688, 292, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 55, "type": "text", "text": "", "page_idx": 4, "bbox": [306, 63.68701934814453, 527, 131.02944946289062], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 56, "type": "text", "text": "4.1 Natural Language Code Search ", "text_level": 1, "page_idx": 4, "bbox": [306, 143, 480, 155], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 57, "type": "text", "text": "Given a natural language as the input, the objec- tive of code search is to ﬁnd the most semantically related code from a collection of codes. We con- duct experiments on the CodeSearchNet corpus ( Husain et al. ,  2019 )   4 . We follow the ofﬁcial evalu- ation metric to calculate the Mean Reciprocal Rank (MRR) for each pair of test data   $(c,w)$   over a ﬁxed set of 999 distractor codes. We further calculate the macro-average MRR for all languages as an overall evaluation metric. It is helpful to note that this met- ric differs from the  AVG  metric in the original pa- per, where the answer is retrieved from candidates from all six languages. We ﬁne-tune a language- speciﬁc model for each programming language 5 . We train each model with a binary classiﬁcation loss function, where a  softmax  layer is connected to the representation of    $[C L S]$  . Both training and validation datasets are created in a way that posi- tive and negative samples are balanced. Negative samples consist of balanced number of instances with randomly replaced NL (i.e.   $(c,\\,\\hat{w}))$  )) and PL (i.e.   $(\\hat{c},w)_{\\perp}$  )). Detailed hyper-parameters for model ﬁne-tuning are given in Appendix B.2. ", "page_idx": 4, "bbox": [306, 161.40602111816406, 527, 472.63348388671875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 58, "type": "text", "text": "Model Comparisons Table  2  shows the results of different approaches on the CodeSearchNet cor- pus. The ﬁrst four rows are reported by  Husain et al.  ( 2019 ), which are joint embeddings of NL and PL ( Gu et al. ,  2018 ;  Mitra et al. ,  2018 ).  NB O W represents neural bag-of-words.  CNN ,  B I RNN and  S ELF ATT  stand for 1D convolultional neu- ral network ( Kim ,  2014 ), bidirectional GRU-based recurrent neural network ( Cho et al. ,  2014 ), and multi-head attention ( Vaswani et al. ,  2017 ), respec- tively. ", "page_idx": 4, "bbox": [306, 482.33428955078125, 527, 631.3644409179688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 59, "type": "text", "text": "We report the remaining numbers in Table  2 . We train all these pre-trained models by regarding codes as a sequence of tokens. We also continu- ously train RoBERTa only on codes from Code- SearchNet with masked language modeling. Re- sults show that CodeBERT consistently performs ", "page_idx": 4, "bbox": [306, 632.4400024414062, 527, 713.3314208984375], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 60, "type": "table", "page_idx": 5, "img_path": "layout_images/2020.findings-emnlp.139_3.jpg", "table_footnote": "Table 2: Results on natural language code retrieval. Baselines include four joint embeddings (ﬁrst group) of NL and PL, RoBERTa, and RoBERTa which is continuously trained with masked language modeling on codes only (second group). PT stands for pre-training. We train CodeBERT (third group) with different settings, including using different initialization (from scratch   $\\scriptstyle\\left(\\mathrm{{NIT}}=\\mathbf{S}\\right)$  ) or initialized with the parameters of RoBERTa   $\\scriptstyle\\left(\\mathrm{{INIT=R}}\\right)$  ) and using different learning objectives (MLM, RTD, or the combination of both). ", "bbox": [71, 62, 526, 270], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "MODEL RUBY JAVASCRIPT GO PYTHON JAVA PHP MA-AvG\nNBow 0.4285 0.4607 0.6409 0.5809 0.5140 0.4835 0.5181\nCNN 0.2450 0.3523 0.6274 0.5708 0.5270 0.5294 0.4753\nBIRNN 0.0835 0.1530 0.4524 0.3213 0.2865 0.2512 0.2580\nSELFATT 0.3651 0.4506 0.6809 0.6922 0.5866 0.6011 0.5628\nROBERTA 0.6245 0.6060 0.8204 0.8087 0.6659 0.6576 0.6972\nPT w/ CODE ONLY (INIT=S) 0.5712 0.5557 0.7929 0.7855 0.6567 =0.6172 0.6632\nPT w/ CODE ONLY (INIT=R) 0.6612 0.6402 0.8191 0.8438 0.7213 0.6706 0.7260\nCODEBERT (MLM, INIT=s) 0.5695 0.6029 0.8304 0.8261 0.7142 0.6556 0.6998\nCoDEBERT (MLM, INIT=R) 0.6898 0.6997 0.8383 0.8647 0.7476 0.6893 0.7549\nCODEBERT (RTD, INIT=R) 0.6414 0.6512 0.8285 0.8263 0.7150 0.6774 0.7233\nCoDEBERT (MLM+RTD, INIT=R) 0.6926 0.7059 0.8400 0.8685 0.7484 0.7062 0.7603\n", "vlm_text": "This table presents performance metrics of different models across various programming languages including Ruby, JavaScript, Go, Python, Java, and PHP. The models compared are NBow, CNN, BiRNN, SelfAtt, RoBERTa, PT with Code Only (two initialization strategies), and various configurations of CodeBERT. \n\nEach column (except for the model column and MA-Avg) represents the performance score of these models on a specific language. The MA-Avg column shows the mean average performance score of each model across all languages.\n\nThe best scores for each language are highlighted in bold, with \"CodeBERT (MLM+RTD, init=R)\" generally showing the highest performance across most languages and the mean average."}
{"layout": 61, "type": "text", "text": "better than RoBERTa and the model pre-trained with code only. CodeBERT (MLM) learned from scratch performs better than RoBERTa. Unsur- prisingly, initializing CodeBERT with RoBERTa improves the performance   6 . ", "page_idx": 5, "bbox": [71, 291.83197021484375, 291, 359.1744689941406], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 62, "type": "text", "text": "4.2 NL-PL Probing ", "text_level": 1, "page_idx": 5, "bbox": [72, 370, 170, 382], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 63, "type": "text", "text": "In the previous subsection, we show the empirical effectiveness of CodeBERT in a setting that the parameters of CodeBERT are ﬁne-tuned in down- stream tasks. In this subsection, we further inves- tigate what type of knowledge is learned in Code- BERT without modifying the parameters. ", "page_idx": 5, "bbox": [71, 388.1159973144531, 291, 469.0074768066406], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 64, "type": "text", "text": "Task Formulation and Data Construction Fol- lowing the probing experiments in NLP ( Petroni et al. ,  2019 ;  Talmor et al. ,  2019 ), we study NL- PL probing here. Since there is no existing work towards this goal, we formulate the problem of NL-PL probing and create the dataset by ourselves. Given an NL-PL pair   $(c,\\,\\pmb{w})$  , the goal of NL-PL probing is to test model’s ability to correctly pre- dict/recover the masked token of interest (either a code token    $c_{i}$   or word token  $w_{j}.$  ) among distractors. There are two major types of distractors: one is the whole target vocabulary used for the masked lan- guage modeling objective ( Petroni et al. ,  2019 ), and another one has fewer candidates which are ﬁlter or curated based on experts’ understanding about the ability to be tested ( Talmor et al. ,  2019 ). We follow the second direction and formulate NL-PL probing as a multi-choice question answering task, where the question is cloze-style in which a certain token is replaced by    $[M A S K]$   and distractor candidate answers are curated based on our expertise. ", "page_idx": 5, "bbox": [71, 477.7972717285156, 291, 735.221435546875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 65, "type": "text", "text": "", "page_idx": 5, "bbox": [307, 291, 527, 318.5264587402344], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 66, "type": "text", "text": "Speciﬁcally, we evaluate on the NL side and PL side, respectively. To ease the effort of data col- lection, we collect data automatically from NL-PL pairs in both validation and testing sets of Code- SearchNet, both of which are unseen in the pre- training phase. To evaluate on the NL side, we select NL-PL pairs whose NL documentations in- clude one of the six keywords ( max ,  maximize ,  min , minimize ,  less ,  greater ), and group them to four candidates by merging ﬁrst two keywords and the middle two keywords. The task is to ask pre-trained models to select the correct one instead of three other distractors. That is to say, the input in this setting includes the complete code and a masked NL documentation. The goal is to select the correct answer from four candidates. For the PL side, we select codes containing keywords  max  and  min , and formulate the task as a two-choice answer selection problem. Here, the input includes complete NL documentation and a masked PL code, and the goal is to select the correct answer from two candidates. Since code completion is an important scenario, we would like to test model’s ability in predicting the correct token merely based on preceding PL contexts. Therefore, we add an additional setting for PL side, where the input includes the complete NL documentation and preceding PL codes. Data statistics is given in the top two rows in Table  3 . ", "page_idx": 5, "bbox": [307, 320.4010009765625, 527, 699.3754272460938], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 67, "type": "text", "text": "Model Comparisons Results are given in Table 3 . We report accuracy, namely the number of cor- rectly predicted instances over the number of all instances, for each programming language. Since ", "page_idx": 5, "bbox": [307, 711.8452758789062, 527, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 68, "type": "table", "page_idx": 6, "img_path": "layout_images/2020.findings-emnlp.139_4.jpg", "table_footnote": "Table 3: Statistics of the data for NL-PL probing and the performance of different pre-trained models. Accuracies  $(\\%)$   are reported. Best results in each group are in bold. ", "bbox": [71, 62, 526, 274], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "RUBY JAVASCRIPT GO PYTHON JAVA PHP ALL\nNUMBER OF DATAPOINTS FOR PROBING\nPL (2 CHOICES) 38 212. 152 1,264 482 407 2,615\nNL (4 CHOICES) 20 65 159 216 323 73 856\nPL PROBING\nROBERTA 73.68 63.97 72.37 59.18 59.96 69.78 62.45\nPRE-TRAIN W/ CODE ONLY 71.05 77.94 89.47 70.41 70.12 82.31 74.11\nCODEBERT (MLM) 86.84 86.40 90.79 82.20 90.46 88.21 85.66\nPL PROBING WITH PRECEDING CONTEXT ONLY\nROBERTA 73.68 53.31 51,32 55.14 42.32 52.58 52.24\nPRE-TRAIN W/ CODE ONLY 63.16 48.53 61.84 56.25 58.51 58.97 56.71\nCODEBERT (MLM) 65.79 50.74 59.21 62.03 54.98 59.95 59.12\nNL PROBING\nROBERTA 50.00 ‘72331 54.72 61.57 61.61 65.75 61.21\nPRE-TRAIN W/ CODE ONLY 55.00 67.69 60.38 68.06 65.02 68.49 65.19\nCODEBERT (MLM) 65.00 89.23 66.67 76.85 73.37 79.45 74.53\n", "vlm_text": "This table presents the results of several experiments evaluating the performance of different models on probing tasks related to programming languages (PL) and natural languages (NL) across different programming languages: Ruby, JavaScript, Go, Python, Java, and PHP.\n\nHere's a breakdown of the table's contents:\n\n1. **Number of Datapoints for Probing:**\n   - **PL (2 choices):** It lists the number of data points for each programming language used in probing tasks that have two choices: Ruby (38), JavaScript (272), Go (152), Python (1,264), Java (482), PHP (407), and a total of (2,615).\n   - **NL (4 choices):** It lists the number of data points for each programming language used in probing tasks that have four choices: Ruby (20), JavaScript (65), Go (159), Python (216), Java (323), PHP (73), and a total of (856).\n\n2. **PL Probing:**\n   - Evaluates the performance of different models on programming language probing tasks.\n   - **Roberta:** Shows performance metrics for Ruby (73.68), JavaScript (63.97), Go (72.37), Python (59.18), Java (59.96), PHP (69.78), with an overall score of (62.45).\n   - **Pre-Train w/ Code Only:** Performance scores are Ruby (71.05), JavaScript (77.94), Go (89.47), Python (70.41), Java (70.12), PHP (82.31), with an overall score of (74.11).\n   - **CodeBERT (MLM):** Performance scores are Ruby (86.84), JavaScript (86.40), Go (90.79), Python (82.20), Java (90.46), PHP (88.21), with an overall score of (85.66).\n\n3. **PL Probing with Preceding Context Only:**\n   - Measures model performance when preceding context is considered.\n   - **Roberta:** Ruby (73.68), JavaScript (53.31), Go (51.32), Python (55.14), Java (42.32), PHP (52.58), overall (52.24).\n   - **Pre-Train w/ Code Only:** Ruby (63.16), JavaScript (48.53), Go (61.84), Python (56.25), Java (58.51), PHP (58.97), overall (56.71).\n   - **CodeBERT (MLM):** Ruby (65.79), JavaScript (50.74), Go (59.21), Python (62.03), Java (54.98), PHP (59.95), overall (59.12).\n\n4. **NL Probing:**\n   - Evaluates the models on natural language tasks.\n"}
{"layout": 69, "type": "text", "text": "datasets in different programming languages are extremely unbalanced, we report the accumulated metric with the same way. We use CodeBERT (MLM) here because its output layer naturally ﬁts for probing. Results show that CodeBERT per- forms better than baselines on almost all languages on both NL and PL probing. The numbers with only preceding contexts are lower than that with bidirectional contexts, which suggests that code completion is challenging. We leave it as a future work. ", "page_idx": 6, "bbox": [71, 295.0780029296875, 292, 443.7154846191406], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 70, "type": "text", "text": "We further give a case study on PL-NL probing. We mask NL token and PL token separately, and report the predicted probabilities of RoBERTa and CodeBERT. Figure  3  illustrates the example of a python code 7 . We can see that RoBERTa fails in both cases, whereas CodeBERT makes the correct prediction in both NL and PL settings. ", "page_idx": 6, "bbox": [71, 444.45599365234375, 292, 538.896484375], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 71, "type": "text", "text": "4.3 Code Documentation Generation ", "text_level": 1, "page_idx": 6, "bbox": [71, 550, 252, 562], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 72, "type": "text", "text": "Although the pre-training objective of Code- BERT does not include generation-based objectives ( Lewis et al. ,  2019 ), we would like to investigate to what extent does CodeBERT perform on gen- eration tasks. Speciﬁcally, we study code-to-NL generation, and report results for the documenta- tion generation task on CodeSearchNet Corpus in six programming languages. Since the generated documentations are short and higher order n-grams may not overlap, we remedy this problem by using smoothed BLEU score ( Lin and Och ,  2004 ). ", "page_idx": 6, "bbox": [71, 567.4519653320312, 292, 716.0894775390625], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 73, "type": "image", "page_idx": 6, "img_path": "layout_images/2020.findings-emnlp.139_5.jpg", "bbox": [307, 291, 525, 430], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "masked NL token\n\"Transforms a vector np.arange(-N, M, dx) to np.arange( {min]( |vec/),\nmax(N,M),dx)]\"\n\ndef vec_to_halfvec(vec):\n\nd = vec[1:] - vec[:-1]\nif ((d/d.mean()).std() > 1e-14) or (d.mean() < 0):\nraise ValueError('vec must be np.arange() in increasing order’)\ndx = d.mean() masked PL token\nlowest = np.absivec) I : :\nhighest = np.abs(vec).max()\nreturn np.arange(lowest, highest + 0.1*dx, dx).astype(vec.dtype)\n", "vlm_text": "The image is a code snippet from a Python function named `vec_to_halfvec`. The function takes a vector `vec` and transforms `np.arange(-N, M, dx)` to `np.arange(min(|vec|), max(N, M), dx)`. \n\nHighlighted elements in the image include:\n- A masked natural language (NL) token, `min`, found in the caption string above the function definition.\n- The line of code `lowest = np.abs(vec).min()` has a masked programming language (PL) token, `min`.\n\nThe function:\n1. Calculates the difference `d` between consecutive elements of the input vector `vec`.\n2. Checks if the standard deviation of `d/d.mean()` is greater than `1e-14` or if `d.mean()` is less than `0` to raise a `ValueError` if the conditions are met.\n3. Computes `dx` as the mean of `d`.\n4. Determines the `lowest` and `highest` values as the minimum and maximum of the absolute values of `vec`, respectively.\n5. Returns a range using `np.arange(lowest, highest + 0.1*dx, dx)` with the same data type as `vec`."}
{"layout": 74, "type": "table", "page_idx": 6, "img_path": "layout_images/2020.findings-emnlp.139_6.jpg", "bbox": [308, 432, 526, 492], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "max min less greater\nNL Roberta 96.24% 3.73% 0.02% 0.01%\nCodeBERT (MLM) | 39.38% 60.60% 0.02% 0.0003%\nPE Roberta 95.85% 4.15% = =\nCodeBERT (MLM) | 0.001% | 99.999% = S\n\n", "vlm_text": "The table compares the performance of two models, Roberta and CodeBERT (MLM), across two different contexts, NL (Natural Language) and PL (Programming Language). It presents data in terms of four metrics: max, min, less, and greater.\n\n### For NL:\n- **Roberta**\n  - Max: 96.24%\n  - Min: 3.73%\n  - Less: 0.02%\n  - Greater: 0.01%\n\n- **CodeBERT (MLM)**\n  - Max: 39.38%\n  - Min: 60.60%\n  - Less: 0.02%\n  - Greater: 0.0003%\n\n### For PL:\n- **Roberta**\n  - Max: 95.85%\n  - Min: 4.15%\n  - Less: -\n  - Greater: -\n\n- **CodeBERT (MLM)**\n  - Max: 0.001%\n  - Min: 99.999%\n  - Less: -\n  - Greater: -\n\nThe table uses two colors to differentiate between NL and PL rows, with the former in blue and the latter in light yellow."}
{"layout": 75, "type": "text", "text": "Figure 3: Case study on python language. Masked to- kens in NL (in blue) and PL (in yellow) are separately applied. Predicted probabilities of RoBERTa and Code- BERT are given. ", "page_idx": 6, "bbox": [306, 502.5605773925781, 527, 550.4314575195312], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 76, "type": "text", "text": "Model Comparisons We compare our model with several baselines, including a RNN-based model with attention mechanism ( Sutskever et al. , 2014 ), the Transformer ( Vaswani et al. ,  2017 ), RoBERTa and the model pre-trained on code only. To demonstrate the effectiveness of CodeBERT on code-to-NL generation tasks, we adopt various pre-trained models as encoders and keep the hyper- parameters consistent. Detailed hyper-parameters are given in Appendix B.3. ", "page_idx": 6, "bbox": [306, 562.3272705078125, 527, 697.8084716796875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 77, "type": "text", "text": "Table  4  shows the results with different mod- els for the code-to-documentation generation task. As we can see, models pre-trained on program- ming language outperform RoBERTa, which illus- trates that pre-trainning models on programming ", "page_idx": 6, "bbox": [306, 698.6890258789062, 527, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 78, "type": "table", "page_idx": 7, "img_path": "layout_images/2020.findings-emnlp.139_7.jpg", "table_footnote": "Table 4: Results on Code-to-Documentation generation, evaluated with smoothed BLEU-4 score. ", "bbox": [99, 61, 497, 169], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "MODEL RUBY JAVASCRIPT Go PYTHON JAVA PHP OVERALL\nSEQ2SEQ 9.64 10.21 13.98 15.93 15.09 21.08 14.32\nTRANSFORMER 11.18 11.59 16.38 15.81 16.26 22.12 15.56\nROBERTA 11.17 11.90 17.72 18.14 16.47 24.02 16.57\nPRE-TRAIN W/ CODEONLY 11.91 13.99 17.78 18.58 17.50 24.34 17.35\nCoDEBERT (RTD) 11.42 13.27 17.53 18.29 17.35 24.10 17.00\nCoDEBERT (MLM) 11.57 14.41 17.78 18.77 17.38 24.85 17.46\nCoDEBERT (RTD+MLM) 12.16 14.90 18.07 19.06 17.65 25.16 17.83\n", "vlm_text": "The table presents a comparison of different models evaluated on specific programming languages, including Ruby, JavaScript, Go, Python, Java, and PHP. The models listed are:\n\n1. SEQ2SEQ\n2. Transformer\n3. RoBERTa\n4. Pre-trained with Code Only\n5. CodeBERT (RTD)\n6. CodeBERT (MLM)\n7. CodeBERT (RTD+MLM)\n\nEach model is evaluated based on its performance across the aforementioned programming languages, and an \"Overall\" score is provided, which likely represents a weighted or averaged performance metric across all languages.\n\nFrom the table, it is observed that CodeBERT (RTD+MLM) generally achieves the highest scores across all columns, indicating superior performance in comparison to the other models for each of the programming languages and overall."}
{"layout": 79, "type": "text", "text": "language could improve code-to-NL generation. Besides, results in the Table  4  show that CodeBERT pre-trained with RTD and MLM objectives brings a gain of 1.3 BLEU score over RoBERTa overall and achieve the state-of-the-art performance 8 . ", "page_idx": 7, "bbox": [71, 191.56800842285156, 292, 258.9104919433594], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 80, "type": "text", "text": "4.4 Generalization to Programming Languages NOT in Pre-training ", "text_level": 1, "page_idx": 7, "bbox": [71, 268, 247, 296], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 81, "type": "text", "text": "We would like to evaluate CodeBERT on the pro- gramming language which is never seen in the pre- training step. To this end, we study the task of gen- erating a natural language summary of a C# code snippet. We conduct experiments on the dataset of CodeNN ( Iyer et al. ,  $2016)^{9}$  , which consists of 66,015 pairs of questions and answers automati- cally collected from StackOverﬂow. This dataset is challenging since the scale of dataset is orders of magnitude smaller than CodeSearchNet Corpus. We evaluate models using smoothed BLEU-4 score and use the same evaluation scripts as  Iyer et al. ( 2016 ). ", "page_idx": 7, "bbox": [71, 300.48797607421875, 292, 476.2234802246094], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 82, "type": "table", "page_idx": 7, "img_path": "layout_images/2020.findings-emnlp.139_8.jpg", "table_footnote": "Table 5: Code-to-NL generation on C# language. ", "bbox": [74, 485, 286, 658], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "MODEL BLEU\nMOSES (KOEHN ET AL., 2007) 11557\nIR 13.66\nSUM-NN (RUSH ET AL., 2015) 19.31\n2-LAYER BILSTM 19.78\nTRANSFORMER (VASWANIET AL., 2017) ~—- 19.68\nTREELSTM (TAI ET AL., 2015) 20.11\nCODENN (IYER ET AL., 2016) 20.53\nCODE2SEQ (ALON ET AL., 2019) 23.04\nROBERTA 19.81\nPRE-TRAIN W/ CODE ONLY 20.65\nCODEBERT (RTD) 22.14\nCODEBERT (MLM) 22.32\nCODEBERT (MLM+RTD) 22.36\n", "vlm_text": "This table compares different models based on their BLEU scores. Here are the details:\n\n- **MOSES** (Koehn et al., 2007) - 11.57\n- **IR** - 13.66\n- **SUM-NN** (Rush et al., 2015) - 19.31\n- **2-layer BiLSTM** - 19.78\n- **Transformer** (Vaswani et al., 2017) - 19.68\n- **TreeLSTM** (Tai et al., 2015) - 20.11\n- **CodeNN** (Iyer et al., 2016) - 20.53\n- **Code2Seq** (Alon et al., 2019) - 23.04\n\nAdditional models and variations:\n\n- **RoBERTa** - 19.81\n- Pre-train w/ code only - 20.65\n- **CodeBERT (RTD)** - 22.14\n- **CodeBERT (MLM)** - 22.32\n- **CodeBERT (MLM+RTD)** - 22.36\n\nThe highest BLEU score is achieved by CodeBERT (MLM+RTD) with a score of 22.36."}
{"layout": 83, "type": "text", "text": "Model Comparisons Table  5  shows that our model with MLM and RTD pre-training objectives achieves 22.36 BLEU score and improves by 2.55 points over RoBERTa, which illustrates CodeBERT could generalize better to other programming lan- guage which is never seen in the pre-training step. However, our model achieve slightly lower results than code2seq ( Alon et al. ,  2019 ). The main reason could be that code2seq makes use of compositional paths in its abstract syntax tree (AST) while Code- BERT only takes original code as the input. We have trained a version of CodeBERT by traversing the tree structure of AST following a certain order, but applying that model does not bring improve- ments on generation tasks. This shows a potential direction to improve CodeBERT by incorporating AST. ", "page_idx": 7, "bbox": [71, 680.7943115234375, 292, 734.9794311523438], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 84, "type": "text", "text": "", "page_idx": 7, "bbox": [307, 191.56800842285156, 527, 367.303466796875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 85, "type": "text", "text": "5 Conclusion ", "text_level": 1, "page_idx": 7, "bbox": [307, 378, 383, 391], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 86, "type": "text", "text": "In this paper, we present CodeBERT, which to the best of our knowledge is the ﬁrst large  bimodal pre-trained model for natural language and pro- gramming language. We train CodeBERT on both bimodal  and  unimodal  data, and show that ﬁne- tuning CodeBERT achieves state-of-the-art perfor- mance on downstream tasks including natural lan- guage code search and code-to-documentation gen- eration. To further investigate the knowledge em- bodied in pre-trained models, we formulate the task of NL-PL probing and create a dataset for probing. We regard the probing task as a cloze-style answer selection problem, and curate distractors for both NL and PL parts. Results show that, with model parameters  ﬁxed, CodeBERT performs better than RoBERTa and a continuously trained model using codes only. ", "page_idx": 7, "bbox": [307, 400.35198974609375, 527, 630.284423828125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 87, "type": "text", "text": "There are many potential directions for further research on this ﬁeld. First, one could learn better generators with  bimodal  evidence or more compli- cated neural architecture to improve the replaced to- ken detection objective. Second, the loss functions of CodeBERT mainly target on NL-PL understand- ing tasks. Although CodeBERT achieves strong BLEU scores on code-to-documentation genera- tion, the CodeBERT itself could be further im- proved by generation-related learning objectives. ", "page_idx": 7, "bbox": [307, 630.9429931640625, 527, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 88, "type": "text", "text": "How to successfully incorporate AST into the pre- training step is also an attractive direction. Third, we plan to apply CodeBERT to more NL-PL re- lated tasks, and extend it to more programming languages. Flexible and powerful domain/language adaptation methods are necessary to generalize well. ", "page_idx": 8, "bbox": [71, 63.68701934814453, 292, 158.12844848632812], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 89, "type": "text", "text": "Acknowledgments ", "text_level": 1, "page_idx": 8, "bbox": [71, 170, 167, 182], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 90, "type": "text", "text": "Xiaocheng Feng is the corresponding author of this work. We thank the anonymous reviewers for their insightful comments. Zhangyin Feng, Xiaocheng Feng, Bing Qin and Ting Liu are supported by the National Key R&D Program of China via grant 2018YFB1005103 and National Natural Science Foundation of China (NSFC) via grant 61632011 and 61772156. ", "page_idx": 8, "bbox": [71, 191.29103088378906, 292, 299.2814636230469], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 91, "type": "text", "text": "References ", "text_level": 1, "page_idx": 8, "bbox": [71, 324, 128, 336], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 92, "type": "text", "text": "Uri Alon, Shaked Brody, Omer Levy, and Eran Yahav. 2019. code2seq: Generating sequences from struc- ", "page_idx": 8, "bbox": [71, 342.6935729980469, 292, 365.65753173828125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 93, "type": "text", "text": "enceon Learning Representations . Kyunghyun Cho, Bart Van Merri¨ enboer, Caglar Gul- cehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. 2014. Learning phrase representations using rnn encoder-decoder for statistical machine translation. arXiv preprint arXiv:1406.1078 . Kevin Clark, Minh-Thang Luong, Quoc V. Le, and Christopher D. Manning. 2020.    $\\{{\\mathrm{ELECT}}_{\\mathrm{IRA}}\\}$  : Pre- training text encoders as discriminators rather than generators. In  International Conference on Learn- ing Representations . Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language understand- ing.  arXiv preprint arXiv:1810.04805 . Xiaodong Gu, Hongyu Zhang, and Sunghun Kim. 2018. Deep code search. In  2018 IEEE/ACM 40th Interna- tional Conference on Software Engineering (ICSE) , pages 933–944. IEEE. Hamel Husain, Ho-Hsiang Wu, Tiferet Gazit, Miltiadis Allamanis, and Marc Brockschmidt. 2019. Code- searchnet challenge: Evaluating the state of seman- tic code search.  arXiv preprint arXiv:1909.09436 . Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. 2016. Summarizing source code using a neural attention model. In  Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 2073–2083. ", "page_idx": 8, "bbox": [71, 375.569580078125, 292, 765.7654418945312], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 94, "type": "text", "text": "Dan Jurafsky. 2000. Speech & language processing . Pearson Education India. ", "page_idx": 8, "bbox": [307, 64.5615234375, 527, 87.52544403076172], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 95, "type": "text", "text": "Aditya Kanade, Petros Maniatis, Gogul Balakrish- nan, and Kensen Shi. 2019. Pre-trained contex- tual embedding of source code. arXiv preprint arXiv:2001.00059 . ", "page_idx": 8, "bbox": [307, 96.33251953125, 527, 141.2134246826172], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 96, "type": "text", "text": "Yoon Kim. 2014. Convolutional neural net- works for sentence classiﬁcation. arXiv preprint arXiv:1408.5882 . ", "page_idx": 8, "bbox": [307, 150.0205078125, 527, 183.9424285888672], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 97, "type": "text", "text": "Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris Callison-Burch, Marcello Federico, Nicola Bertoldi, Brooke Cowan, Wade Shen, Christine Moran, Richard Zens, et al. 2007. Moses: Open source toolkit for statistical machine translation. In  Pro- ceedings of the 45th annual meeting of the associ- ation for computational linguistics companion vol- ume proceedings of the demo and poster sessions , pages 177–180. ", "page_idx": 8, "bbox": [307, 192.74951171875, 527, 292.42535400390625], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 98, "type": "text", "text": "Mike Lewis, Yinhan Liu, Naman Goyal, Mar- jan Ghazvininejad, Abdelrahman Mohamed, Omer Levy, Ves Stoyanov, and Luke Zettlemoyer. 2019. Bart: Denoising sequence-to-sequence pre-training for natural language generation, translation, and comprehension.  arXiv preprint arXiv:1910.13461 . ", "page_idx": 8, "bbox": [307, 301.23138427734375, 527, 368.03125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 99, "type": "text", "text": "Chin-Yew Lin and Franz Josef Och. 2004. Orange: a method for evaluating automatic evaluation metrics for machine translation. In  Proceedings of the 20th international conference on Computational Linguis- tics , page 501. Association for Computational Lin- guistics. ", "page_idx": 8, "bbox": [307, 376.8373107910156, 527, 443.63720703125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 100, "type": "text", "text": "Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Man- dar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. Roberta: A robustly optimized bert pretraining ap- proach.  arXiv preprint arXiv:1907.11692 . ", "page_idx": 8, "bbox": [307, 452.4432678222656, 527, 508.2841796875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 101, "type": "text", "text": "Jiasen Lu, Dhruv Batra, Devi Parikh, and Stefan Lee. 2019. Vilbert: Pretraining task-agnostic visi- olinguistic representations for vision-and-language tasks. In  Advances in Neural Information Process- ing Systems , pages 13–23. ", "page_idx": 8, "bbox": [307, 517.0902099609375, 527, 572.93017578125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 102, "type": "text", "text": "Bhaskar Mitra, Nick Craswell, et al. 2018. An intro- duction to neural information retrieval.  Foundations and Trends® in Information Retrieval , 13(1):1–126. ", "page_idx": 8, "bbox": [307, 581.7372436523438, 527, 615.66015625], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 103, "type": "text", "text": "Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. 2018. Deep contextualized word repre- sentations.  arXiv preprint arXiv:1802.05365 . ", "page_idx": 8, "bbox": [307, 624.4662475585938, 527, 669.3482055664062], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 104, "type": "text", "text": "Fabio Petroni, Tim Rockt¨ aschel, Patrick Lewis, Anton Bakhtin, Yuxiang Wu, Alexander H Miller, and Se- bastian Riedel. 2019. Language models as knowl- edge bases?  arXiv preprint arXiv:1909.01066 . ", "page_idx": 8, "bbox": [307, 678.104248046875, 527, 723.0361938476562], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 105, "type": "text", "text": "Telmo Pires, Eva Schlinger, and Dan Garrette. 2019. How multilingual is multilingual bert? arXiv preprint arXiv:1906.01502 . ", "page_idx": 8, "bbox": [307, 731.8422241210938, 527, 765.7651977539062], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 106, "type": "text", "text": "Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. 2018. Improving language understanding by generative pre-training. URL https://s3-us-west-2. amazonaws. com/openai- assets/researchcovers/language unsupervised/language understanding paper. pdf . ", "page_idx": 9, "bbox": [71, 64.56158447265625, 299, 131.36143493652344], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 107, "type": "text", "text": "Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2019. Exploring the limits of transfer learning with a uniﬁed text-to-text trans- former.  arXiv preprint arXiv:1910.10683 . ", "page_idx": 9, "bbox": [71, 141.28350830078125, 292, 197.12437438964844], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 108, "type": "text", "text": "Alexander M Rush, Sumit Chopra, and Jason We- ston. 2015. A neural attention model for ab- stractive sentence summarization. arXiv preprint arXiv:1509.00685 . ", "page_idx": 9, "bbox": [71, 207.04644775390625, 292, 251.92832946777344], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 109, "type": "text", "text": "Chen Sun, Austin Myers, Carl Vondrick, Kevin Mur- phy, and Cordelia Schmid. 2019. Videobert: A joint model for video and language representation learn- ing.  arXiv preprint arXiv:1904.01766 . ", "page_idx": 9, "bbox": [71, 261.85040283203125, 292, 306.7322998046875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 110, "type": "text", "text": "Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014. Sequence to sequence learning with neural networks. In  Advances in neural information processing sys- tems , pages 3104–3112. ", "page_idx": 9, "bbox": [71, 316.65435791015625, 292, 361.5362548828125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 111, "type": "text", "text": "Kai Sheng Tai, Richard Socher, and Christopher D Manning. 2015. Improved semantic representations from tree-structured long short-term memory net- works.  arXiv preprint arXiv:1503.00075 . ", "page_idx": 9, "bbox": [71, 371.45831298828125, 292, 416.3402099609375], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 112, "type": "text", "text": "Alon Talmor, Yanai Elazar, Yoav Goldberg, and Jonathan Berant. 2019. olmpics–on what lan- guage model pre-training captures.  arXiv preprint arXiv:1912.13283 . ", "page_idx": 9, "bbox": [71, 426.26226806640625, 292, 471.1441650390625], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 113, "type": "text", "text": "Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In  Advances in neural information pro- cessing systems , pages 5998–6008. ", "page_idx": 9, "bbox": [71, 481.06622314453125, 292, 536.9071044921875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 114, "type": "text", "text": "Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad Norouzi, Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, et al. 2016. Google’s neural machine translation system: Bridging the gap between hu- man and machine translation. arXiv preprint arXiv:1609.08144 . ", "page_idx": 9, "bbox": [71, 546.8291625976562, 292, 624.5880737304688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 115, "type": "text", "text": "Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Car- bonell, Ruslan Salakhutdinov, and Quoc V Le. 2019. Xlnet: Generalized autoregressive pretrain- ing for language understanding. arXiv preprint arXiv:1906.08237 . ", "page_idx": 9, "bbox": [71, 634.5101318359375, 292, 690.35107421875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 116, "type": "text", "text": "A Data Statistic ", "text_level": 1, "page_idx": 9, "bbox": [72, 704, 163, 717], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 117, "type": "text", "text": "Data statistics of the training/validation/testing data splits for six programming languages are given in Table  6 . ", "page_idx": 9, "bbox": [71, 725.7869873046875, 292, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 118, "type": "table", "page_idx": 9, "img_path": "layout_images/2020.findings-emnlp.139_9.jpg", "table_footnote": "Table 6: Data statistics about the CodeSearchNet Cor- pus for natural language code search. ", "bbox": [306, 61, 527, 176], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "CODE SEARCH TRAINING DEV TESTING\nGo 635,635 28,483 14,291\nJAVA 908,886 30,655 26,909\nJAVASCRIPT 247,773 16,505 6,483\nPHP 1,047,406 52,029 28,391\nPYTHON 824,342 46,213 22,176\nRUBY 97,580 4,417 2,279\n", "vlm_text": "The table presents data on code search for various programming languages across three categories: Training, Dev (Development), and Testing. Here are the details:\n\n- **Go**\n  - Training: 635,635\n  - Dev: 28,483\n  - Testing: 14,291\n\n- **Java**\n  - Training: 908,886\n  - Dev: 30,655\n  - Testing: 26,909\n\n- **JavaScript**\n  - Training: 247,773\n  - Dev: 16,505\n  - Testing: 6,483\n\n- **PHP**\n  - Training: 1,047,406\n  - Dev: 52,029\n  - Testing: 28,391\n\n- **Python**\n  - Training: 824,342\n  - Dev: 46,213\n  - Testing: 22,176\n\n- **Ruby**\n  - Training: 97,580\n  - Dev: 4,417\n  - Testing: 2,279"}
{"layout": 119, "type": "text", "text": "B Train Details ", "text_level": 1, "page_idx": 9, "bbox": [306, 198, 396, 211], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 120, "type": "text", "text": "B.1 Pre-training ", "text_level": 1, "page_idx": 9, "bbox": [306, 221, 392, 235], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 121, "type": "text", "text": "We train CodeBERT on one NVIDIA DGX-2 ma- chine using FP16. It combines 16 interconnected NVIDIA Tesla V100 with 32GB memory. We use the following set of hyper-parameters to train mod- els: batchsize is 2,048 and learning rate is 5e-4. We use Adam to update the parameters and set the num- ber of warmup steps as 10K. We set the max length as 512 and the max training step is 100K. Training 1,000 batches of data costs 600 minutes with MLM objective, 120 minutes with RTD objective. ", "page_idx": 9, "bbox": [306, 240.75502014160156, 527, 375.8434753417969], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 122, "type": "text", "text": "B.2 CodeSearch ", "text_level": 1, "page_idx": 9, "bbox": [306, 388, 391, 401], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 123, "type": "text", "text": "In the ﬁne-turning step, we set the learning rate as 1e-5, the batch size as 64, the max sequence length as 200 and the max ﬁne-tuning epoch as 8. As the same with pre-training, We use Adam to update the parameters. We choose the model performed best on the development set, and use that to evaluate on the test set. ", "page_idx": 9, "bbox": [306, 406.9490051269531, 527, 501.38946533203125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 124, "type": "text", "text": "B.3 Code Summarization on Six Programming Languages ", "text_level": 1, "page_idx": 9, "bbox": [305, 513, 466, 541], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 125, "type": "text", "text": "We use Transformer with 6 layers, 768 dimensional hidden states and 12 attention heads as our decoder in all settings. We set the max length of input and inference as 256 and 64, respectively. We use the Adam optimizer to update model parameters. The learning rate and the batch size are 5e-5 and 64, respectively. We tune hyperparameters and perform early stopping on the development set. ", "page_idx": 9, "bbox": [306, 546.0440063476562, 527, 654.034423828125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 126, "type": "text", "text": "B.4 Code Summarization on C# ", "text_level": 1, "page_idx": 9, "bbox": [306, 666, 464, 679], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 127, "type": "text", "text": "Since state-of-the-art methods use RNN as their de- coder, we choose a 2-layer GRU with an attention mechanism as our decoder for a comparison. We ﬁne-tune models using a grid search with the fol- lowing set of hyper-parameters: batchsize is in    $\\{32$  , 64 }  and learning rate is in    $\\{2\\mathrm{e}.5,5\\mathrm{e}.5\\}$  . We report the number when models achieve best performance on the development set. ", "page_idx": 9, "bbox": [306, 685.1400146484375, 527, 773.438720703125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 128, "type": "text", "text": "", "page_idx": 10, "bbox": [71, 63.68701934814453, 291, 90.38247680664062], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 129, "type": "text", "text": "C Learning Curve of CodeSearch ", "text_level": 1, "page_idx": 10, "bbox": [71, 100, 253, 114], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 130, "type": "text", "text": "From Figure  4 , we can see that CodeBERT per- forms better at the early stage, which reﬂects that CodeBERT provides good initialization for learn- ing downstream tasks. ", "page_idx": 10, "bbox": [71, 121.06501007080078, 291, 174.85848999023438], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 131, "type": "image", "page_idx": 10, "img_path": "layout_images/2020.findings-emnlp.139_10.jpg", "bbox": [73, 191, 289, 300], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "88.5\n\n88.0\n\nDev Accuracy of Python\n\n85.0\n\n84.5\n\n83.0\n\n=e Roberta =e Roberta\n~e codesenr =e CodeseRT\n© Pre-train wi code only 82.5 © Pre-train w/ code only\n_ 820\nSas\ng 81.0\ng\n805\n[ar ee 80.0\n795\n\n1 2 3 4 5 6 7 8\nTha umibal oF ESoch\n\n1 2 3 4 S 6 7 8\nThe Number of Epoch\n", "vlm_text": "This image consists of two line graphs side by side, comparing the development accuracy of three different models—Roberta, CodeBERT, and a model pre-trained with code only—across a varying number of epochs. \n\n- The left graph depicts the development accuracy for Python:\n  - CodeBERT (orange line) exhibits consistently high accuracy across epochs, peaking around 87.5% before slightly declining.\n  - The model pre-trained with code only (green line) has a higher starting accuracy than Roberta, showing some fluctuation with a high around the second epoch, eventually stabilizing around 86%.\n  - Roberta (blue line) shows a lower accuracy, starting around 85.4% and exhibits slight fluctuations across epochs.\n\n- The right graph illustrates the development accuracy for Java:\n  - CodeBERT (orange line) starts with accuracy over 82% and shows a decreasing trend over the epochs, ending slightly below 81%.\n  - The model pre-trained with code only (green line) starts just over 80%, peaks around the second epoch, and stabilizes around 80.5%.\n  - Roberta (blue line) starts with a similar trend as the pre-trained model but generally shows lower accuracy, starting just under 80.5% and demonstrating some fluctuation.\n\nOverall, CodeBERT consistently achieves the highest accuracy for both Python and Java during model training across epochs, while Roberta tends to have the lowest accuracy."}
{"layout": 132, "type": "text", "text": "Figure 4: Learning curve of different pre-trained mod- els in the ﬁne-tuning step. We show results on Python and Java. ", "page_idx": 10, "bbox": [71, 309.32855224609375, 291, 345.24346923828125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 133, "type": "text", "text": "D Late Fusion ", "text_level": 1, "page_idx": 10, "bbox": [72, 357, 154, 370], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 134, "type": "text", "text": "In section    $\\S4.1$   , we show that CodeBERT per- forms well in the setting where natural languages and codes have early interactions. Here, we in- vestigate whether CodeBERT is good at working as a uniﬁed encoder. We apply CodeBERT for natural language code search in a later fusion set- ting, where CodeBERT ﬁrst encodes NL and PL separately, and then calculates the similarity by dot- product. In this way, code search is equivalent to ﬁnd the nearest codes in the shared vector space. This scenario also facilitates the use of CodeBERT in an online system, where the representations of codes are calculated in advance. In the runtime, a system only needs to compute the representation of NL and vector-based dot-product. ", "page_idx": 10, "bbox": [71, 378.25299072265625, 291, 581.08740234375], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 135, "type": "table", "page_idx": 10, "img_path": "layout_images/2020.findings-emnlp.139_11.jpg", "table_footnote": "Table 7: Results on natural language code search by late fusion. ", "bbox": [307, 68, 526, 152], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "MODEL RUBY Go\n\nROBERTA 0.0043 0.0030\nPRE-TRAIN W/ CODE ONLY 0.1648 0.4179\nCopEBERT 0.6870 0.8372\n", "vlm_text": "The table compares the performance of three different models—RoBERTa, a model pretrained with code only, and CodeBERT—on tasks related to the Ruby and Go programming languages. The performance is indicated by numerical scores:\n\n1. **RoBERTa**:\n   - Ruby: 0.0043\n   - Go: 0.0030\n\n2. **Pre-Train w/ code only**:\n   - Ruby: 0.1648\n   - Go: 0.4179\n\n3. **CodeBERT**:\n   - Ruby: 0.6870\n   - Go: 0.8372\n\nThese scores suggest that CodeBERT outperforms the other models significantly in both Ruby and Go tasks."}
{"layout": 136, "type": "text", "text": "only. And late fusion performs comparable with the standard way. What’s more, late fusion is more efﬁcient and this setting could be used in an online system. ", "page_idx": 10, "bbox": [307, 174.4720001220703, 527, 228.26449584960938], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 137, "type": "text", "text": "E Case Study ", "text_level": 1, "page_idx": 10, "bbox": [307, 238, 385, 252], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 138, "type": "text", "text": "To qualitatively analyze the effectiveness of Code- BERT, we give some cases for code search and code documentation generation tasks. ", "page_idx": 10, "bbox": [307, 259.79803466796875, 527, 300.0424499511719], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 139, "type": "text", "text": "Considering the limited space, we only give the top2 results of the query for python programming language. As show in Figure  5 , search results are very relevant with query. ", "page_idx": 10, "bbox": [307, 300.44598388671875, 527, 354.23846435546875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 140, "type": "text", "text": "Figure  6  and Figure  7  show the outputs with different models for the code documentation gen- eration task. As we can see, CodeBERT performs better than all baselines. ", "page_idx": 10, "bbox": [307, 354.64300537109375, 527, 408.43548583984375], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 141, "type": "text", "text": "We ﬁne-tune CodeBERT with the following ob- jective, which maximizes the dot-product of the ground truth while minimizing the dot-product of distractors. ", "page_idx": 10, "bbox": [72, 581.490966796875, 292, 635.284423828125], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 142, "type": "equation", "text": "\n$$\n-\\frac{1}{N}\\sum_{i}\\log\\bigg(\\frac{\\exp\\big(E n c(c_{i})^{\\intercal}E n c(w_{i})\\big)}{\\sum_{j}\\exp\\big(E n c(c_{j})^{\\intercal}E n c(w_{i})\\big)}\\bigg)\n$$\n ", "text_format": "latex", "page_idx": 10, "bbox": [78, 638, 281, 674], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 143, "type": "text", "text": "Results are given in Table  7 . We just do this setting on two languages with a relatively small amount of data. ", "page_idx": 10, "bbox": [72, 698.6890258789062, 292, 738.9324340820312], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 144, "type": "text", "text": "We can see that CodeBERT performs better than RoBERTa and the model pre-trained with codes ", "page_idx": 10, "bbox": [72, 739.3369750976562, 292, 766.0314331054688], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 145, "type": "image", "page_idx": 11, "img_path": "layout_images/2020.findings-emnlp.139_12.jpg", "bbox": [89, 75, 507, 273], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "create file and write something\n\nSearch Results (top2)\n\nhttps://github.com/darknessomi/musicbox/blob/master/NEMbox/utils.py#L37-L40\n\ndef create_file(path, default=\"\\n\"):\nif not os.path.exists(path):\nwith open(path, \"w\") as f:\nf.write(default)\n\nhttps://github.com/datakortet/yamldirs/blob/master/yamldirs/filemaker.py#L114-L118\n\ndef make_file(self, filename, content):\n\"Create a new file with name *‘filename** and content ‘content’.\nwith open(filename, ‘w’) as fp:\nfp.write(content)\n\n", "vlm_text": "The image contains a search query and its corresponding search results. The query appears to be \"create file and write something.\"\n\nThe results shown are two code snippets from GitHub repositories with their respective links.\n\n1. The first result is from the repository \"darknessomi/musicbox\" at the file \"NEMbox/utils.py\" lines 37-40. The code snippet defines a function `create_file(path, default=\"\\n\")` that checks if a file at the given path exists and if not, it creates one with the default content.\n\n2. The second result is from the repository \"datakortet/yamldirs\" at the file \"yamldirs/filemaker.py\" lines 114-118. The code snippet defines a method `make_file(self, filename, content)`, which creates a new file with the specified filename and writes the given content to it."}
{"layout": 146, "type": "text", "text": "Figure 5: Python CodeSearch example. The results are searched from 1,156,085 python code data. We only give the top2 results because space is limited. ", "page_idx": 11, "bbox": [72, 285.41455078125, 525.5473022460938, 309.37451171875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 147, "type": "image", "page_idx": 11, "img_path": "layout_images/2020.findings-emnlp.139_13.jpg", "bbox": [88, 325, 509, 475], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "public void addWriteErrorResult(final BulkWriteError writeError,\nfinal IndexMap indexMap) {\nnotNull(\"writeError\", writeError);\nmergeWriteErrors(asList(writeError), indexMap);\n\n}\n\nGold: Add a write error result\n\nCodeBERT: Add a write error result .\n\nPRE-TRAIN W/ CODEONLY : Merges the given write error .\nRoberta: Add a write operation to the map .\n\nTransformer: Adds an error to the write map .\n\nRNN: Add an error map .\n\n", "vlm_text": "The image contains two sections. The first section is a code snippet in Java, with a method definition `addWriteErrorResult`. This method takes two parameters, `BulkWriteError writeError` and `IndexMap indexMap`. The method calls two functions: `notNull` to check that `writeError` is not null, and `mergeWriteErrors`, which appears to merge the write error into an index map using `asList`.\n\nThe second section provides various model-generated captions or descriptions for the code snippet:\n\n1. **Gold**: Add a write error result\n2. **CodeBERT**: Add a write error result.\n3. **PRE-TRAIN W/ CODENOILY**: Merges the given write error.\n4. **Roberta**: Add a write operation to the map.\n5. **Transformer**: Adds an error to the write map.\n6. **RNN**: Add an error map.\n\nThese descriptions seem to be generated by different models attempting to summarize or describe the purpose of the Java code method provided in the first section."}
{"layout": 148, "type": "text", "text": "Figure 6: Java code documentation generation output example. ", "page_idx": 11, "bbox": [173.42799377441406, 485.88555908203125, 424.1168212890625, 497.8905029296875], "page_size": [595.2760009765625, 841.8900146484375]}
{"layout": 149, "type": "image", "page_idx": 11, "img_path": "layout_images/2020.findings-emnlp.139_14.jpg", "bbox": [88, 513, 509, 733], "page_size": [595.2760009765625, 841.8900146484375], "ocr_text": "def create_or_update(self, list_id, subscriber_hash, data):\nsubscriber_hash = check_subscriber_hash(subscriber_hash)\nself.list_id = list_id\nself.subscriber_hash = subscriber_hash\nif 'email_address' not in data:\nraise KeyError(‘The list member must have an email_address')\ncheck_email(data['email_address'])\nif 'status_if_new' not in data:\nraise KeyError('The list member must have a status_if_new’)\nif data['status_if_new’] not in ['subscribed', 'unsubscribed’, ‘cleaned’, ‘pending’, 'transactional'):\nraise ValueError('The list member status_if_new must be one of\n\"subscribed\", \"unsubscribed\", \"cleaned\", \"pending\", or \"transactional\"')\nreturn self._mc_client._put(url=self._build_path(list_id, 'members', subscriber_hash), data=data)\n\nGold: Add or update a list member .\n\nCodeBERT: Create or update a list member .\n\nPRE-TRAIN W/ CODEONLY: Create or update a subscriber .\nRoberta: Create or update an existing record .\n\nTransformer: Create or update a subscription .\n\nRNN: Creates or updates an email address .\n\n", "vlm_text": "The image contains a code snippet and the output of various models attempting to caption the snippet.\n\nThe code snippet defines a Python function `create_or_update` which is intended to add or update a list member. The function checks for the presence of 'email_address' and 'status_if_new' in the input data and raises a `KeyError` if they are missing. It also validates the value of 'status_if_new' and raises a `ValueError` if it's not among the accepted values. Finally, it performs a PUT request using `_mc_client`.\n\nUnderneath the code, various models provide their caption predictions for the code snippet:\n\n1. **Gold**: Add or update a list member.\n2. **CodeBERT**: Create or update a list member.\n3. **PRE-TRAIN W/ CODEONLY**: Create or update a subscriber.\n4. **Roberta**: Create or update an existing record.\n5. **Transformer**: Create or update a subscription.\n6. **RNN**: Creates or updates an email address."}
